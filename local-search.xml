<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/09/02/%5B%E4%BB%8E%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAVector3f%E5%90%91%E9%87%8F%E7%B1%BB%EF%BC%8C%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <url>/2025/09/02/%5B%E4%BB%8E%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAVector3f%E5%90%91%E9%87%8F%E7%B1%BB%EF%BC%8C%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ray tracing in one weekend笔记(1~6)</title>
    <link href="/2025/08/01/Ray%20tracing%20in%20one%20weekend%E7%AC%94%E8%AE%B0%EF%BC%881~6%EF%BC%89/"/>
    <url>/2025/08/01/Ray%20tracing%20in%20one%20weekend%E7%AC%94%E8%AE%B0%EF%BC%881~6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="2-Output-an-Image"><a href="#2-Output-an-Image" class="headerlink" title="2. Output an Image"></a>2. Output an Image</h2><h3 id="为什么使用-255-999-而不是-255？"><a href="#为什么使用-255-999-而不是-255？" class="headerlink" title="为什么使用 255.999 而不是 255？"></a>为什么使用 <code>255.999</code> 而不是 <code>255</code>？</h3><p>这是一个非常经典的计算机图形学技巧，主要目的是<strong>为了处理浮点数精度问题并确保颜色范围的正确映射</strong>。</p><ul><li><p><strong>目标：</strong> 代码的目的是将一个范围在 <code>[0.0, 1.0]</code> 之间的浮点数（如变量 <code>r</code>, <code>g</code>, <code>b</code>）映射到范围在 <code>[0, 255]</code> 之间的整数，用于表示PPM图像格式中的颜色分量。</p></li><li><p><strong>问题：</strong> 计算机在表示浮点数时存在精度限制。一个本应是 <code>1.0</code> 的值，在计算过程中可能会变成一个极其接近1的数，比如 <code>0.9999999999999999</code>。</p></li><li><p><strong>如果用 <code>255</code>：</strong></p><ul><li><p>当 <code>r</code> 的值是 <code>1.0</code> 时，<code>255 * 1.0</code> 等于 <code>255.0</code>，强制类型转换为 <code>int</code> 后得到 <code>255</code>，结果正确。</p></li><li><p>但是，如果 <code>r</code> 的值由于精度问题变成了 <code>0.99999999...</code>，<code>255 * 0.999999...</code> 的结果会是 <code>254.999999...</code>。C++在将浮点数转换为整数时会<strong>截断</strong>小数部分，所以 <code>(int)254.999999...</code> 的结果是 <code>254</code>。</p></li><li><p>这就导致了本应最亮的颜色（255）错误地变成了次亮的颜色（254），图像的色域会不完整。</p></li></ul></li><li><p><strong>使用 <code>255.999</code> 的解决方案：</strong></p><ul><li><p>通过乘以 <code>255.999</code>，我们为这种精度误差提供了一个“安全边界”。</p></li><li><p>当 <code>r</code> 是 <code>1.0</code> 时，<code>255.999 * 1.0</code> 结果是 <code>255.999</code>，转换为 <code>int</code> 是 <code>255</code>。</p></li><li><p>当 <code>r</code> 是 <code>0.99999999...</code> 时，<code>255.999 * 0.999999...</code> 的结果会非常接近 <code>255.999</code>（例如 <code>255.998...</code>），转换为 <code>int</code> 仍然是 <code>255</code>。</p></li></ul></li></ul><p><strong>总结：使用 <code>255.999</code> 是一个健壮的编程技巧，可以确保 <code>[0.0, 1.0]</code> 的浮点数范围被完整且正确地映射到 <code>[0, 255]</code> 的整数范围，避免了因浮点数不精确而导致的最大值丢失问题。</strong></p><hr><h3 id="为什么-r-double-i-image-width-1-？"><a href="#为什么-r-double-i-image-width-1-？" class="headerlink" title="为什么 r = double(i) / (image_width - 1);？"></a>为什么 <code>r = double(i) / (image_width - 1);</code>？</h3><ul><li><p>这行代码的<strong>目的就是在图像上创建一个平滑的颜色渐变，让颜色的强度与像素的位置相关联</strong>。</p></li><li><p>来分解一下这行代码：</p></li><li><p><code>for (int i = 0; i &lt; image_width; i++)</code>: <code>i</code> 是像素的水平位置（列索引），从最左边的 <code>0</code> 变化到最右边的 <code>image_width - 1</code>。</p></li><li><p><code>double(i)</code>: 将整数索引 <code>i</code> 转换为浮点数，以便进行精确的除法运算。</p></li><li><p><code>image_width - 1</code>: 这是整个范围内的最大索引值。为什么要减1？因为像素索引是从0开始的。对于一个宽度为256的图像，它的像素索引范围是 <code>[0, 255]</code>，总共有256个像素。分母使用 <code>image_width - 1</code> (也就是255) 可以确保当 <code>i</code> 取到最大值 <code>255</code> 时，除法的结果正好是 <code>1.0</code>。如果分母是 <code>image_width</code> (256)，那么最大值只能是 <code>255/256</code>，永远达不到 <code>1.0</code>。</p></li><li><p><strong>归一化 (Normalization):</strong> 整个表达式 <code>double(i) / (image_width - 1)</code> 的作用是将像素的水平位置 <code>i</code>（范围 <code>[0, 255]</code>）“归一化”到一个标准的浮点数范围 <code>[0.0, 1.0]</code>。</p></li></ul><p>同理，<code>auto g = double(j) / (image_height - 1);</code> 是将像素的垂直位置 <code>j</code> 归一化到 <code>[0.0, 1.0]</code>。</p><p>最终的效果是：</p><ul><li><p>像素的<strong>红色分量 (<code>r</code>)</strong> 从左到右由 <code>0.0</code> 线性增加到 <code>1.0</code>。</p></li><li><p>像素的<strong>绿色分量 (<code>g</code>)</strong> 从上到下由 <code>0.0</code> 线性增加到 <code>1.0</code>。</p></li><li><p>像素的<strong>蓝色分量 (<code>b</code>)</strong> 始终为 <code>0.0</code>。</p></li></ul><p>这将生成一张从左上角的黑色 (<code>r=0, g=0</code>) 渐变到右下角的黄色 (<code>r=1, g=1</code>)，右上角为红色 (<code>r=1, g=0</code>)，左下角为绿色 (<code>r=0, g=1</code>) 的图像。</p><hr><h2 id="3-vec-h"><a href="#3-vec-h" class="headerlink" title="3. vec.h"></a>3. vec.h</h2><h3 id="ifdef-define-与-pragma-once-的对比"><a href="#ifdef-define-与-pragma-once-的对比" class="headerlink" title="#ifdef &#x2F; #define 与 #pragma once 的对比"></a><strong><code>#ifdef</code> &#x2F; <code>#define</code> 与 <code>#pragma once</code> 的对比</strong></h3><p>预处理指令 <code>#ifndef VEC3_H</code>、<code>#define VEC3_H</code> 和 <code>#endif</code> 共同构成了一个“包含守卫”或“头文件守卫”。它们的作用是防止头文件的内容在单个编译单元中被多次包含。</p><p>它们的工作原理如下：</p><ol><li><p><strong><code>#ifndef VEC3_H</code></strong>: 预处理器检查名为 <code>VEC3_H</code> 的宏是否已经被定义。</p></li><li><p><strong>首次包含</strong>: 第一次包含 <code>vec3.h</code> 时，<code>VEC3_H</code> 尚未被定义。因此，代码会继续执行下一行。</p></li><li><p><strong><code>#define VEC3_H</code></strong>: 这行代码定义了宏 <code>VEC3_H</code>。</p></li><li><p><strong><code>#endif</code></strong>: 文件的其余部分被包含进来，直到文件末尾的 <code>#endif</code>。</p></li><li><p><strong>后续包含</strong>: 如果同一个文件被再次包含，<code>#ifndef VEC3_H</code> 的检查将会失败，因为 <code>VEC3_H</code> 此时已经被定义。预处理器将跳过从此处到最终 <code>#endif</code> 之间的所有内容。</p></li></ol><p><code>#pragma once</code> 是一个更现代的指令，它虽然非标准，但得到了广泛支持，并能实现相同的目标。当预处理器看到 <code>#pragma once</code> 时，它会记录下该文件的路径，并确保在同一次编译中不再包含它。</p><p><strong>它们是等效的吗？</strong></p><p>是的，它们的_效果_基本相同：防止头文件的多次包含。但是，它们之间存在一些关键区别：</p><ul><li><p><strong>标准化</strong>: <code>#define</code> 守卫方法是 C++ 标准的一部分，保证适用于任何合规的编译器。而 <code>#pragma once</code> 不是标准的一部分，但几乎所有现代编译器（如 GCC、Clang 和 MSVC）都支持它。</p></li><li><p><strong>简洁性</strong>: <code>#pragma once</code> 更简单，且不易出错。你只需要输入一行。而使用包含守卫，你必须小心确保宏名称是唯一的，并且不要忘记写 <code>#endif</code>。</p></li><li><p><strong>潜在错误</strong>: 使用 <code>#define</code> 守卫时，如果你不小心在两个不同的文件中使用了相同的宏名称，那么只有一个文件会被包含。这可能会导致非常令人困惑的 bug。</p></li></ul><p>在现代 C++ 中，使用 <code>#pragma once</code> 很常见，但您的示例中使用的 <code>#define</code> 守卫方法是经典的、完全可移植的方式。</p><h3 id="VEC3-H-的含义和惯例"><a href="#VEC3-H-的含义和惯例" class="headerlink" title="VEC3_H 的含义和惯例"></a><strong><code>VEC3_H</code> 的含义和惯例</strong></h3><ul><li><p>VEC3_H 是什么意思？</p><p>  在这里，VEC3_H 仅仅是一个唯一的标识符或宏，预处理器用它来跟踪这个特定文件是否已经被包含。它本身对 C++ 编译器没有任何内在含义。</p></li><li><p>它必须是 VEC3_H 吗？必须大写吗？</p><p>  不，宏的名称并不严格要求与文件名匹配。你本可以使用 SOME_UNIQUE_NAME_HERE 这样的名字。然而，一个被广泛遵循的强大惯例是根据文件名来命名守卫宏，以确保其唯一性。</p><p>  这个惯例通常是：</p><ol><li><p>取文件名 (<code>vec3.h</code>)。</p></li><li><p>将其转换为大写 (<code>VEC3.H</code>)。</p></li><li><p>将宏名称中无效的字符（如’.’）替换为下划线 (<code>_</code>)。这样就得到了 <code>VEC3_H</code>。</p></li></ol><p>  在 C 和 C++ 中，使用大写字母来命名宏也是一个非常普遍的惯例，目的是将它们与变量和函数名区分开来，这有助于避免命名冲突。</p></li></ul><p>总结一下：</p><ul><li><p>包含守卫 <code>#ifndef VEC3_H</code>, <code>#define VEC3_H</code>, <code>#endif</code> 和 <code>#pragma once</code> 的作用相同。<code>#define</code> 方法是标准且可移植的，而 <code>#pragma once</code> 是一个常见且更简洁的非标准扩展。</p></li><li><p><code>VEC3_H</code> 是一个用作标志的唯一预处理器变量。</p></li><li><p>通常遵循一个非常强的惯例：根据文件名来命名守卫宏，并全部使用大写字母，以防止命名冲突。</p></li></ul><hr><h3 id="组织方法"><a href="#组织方法" class="headerlink" title="组织方法"></a>组织方法</h3><ul><li>在<a href="/2025/07/22/%E4%BB%8E%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAVector3f%E5%90%91%E9%87%8F%E7%B1%BB%EF%BC%8C%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" title="从实现一个Vector3f向量类，深入了解运算符重载">从实现一个Vector3f向量类，深入了解运算符重载</a>中也实现了一个三维向量类；但是在文件的组织上选择了不同的方案；<br>首先，我们总结一下两种做法的核心区别：</li></ul><ol><li><p><strong>Vector3f (Separate Files)</strong>:</p><ul><li><p><strong>声明</strong>放在头文件 (<code>.h</code>) 中。</p></li><li><p><strong>定义（实现）</strong>放在源文件 (<code>.cpp</code>) 中。</p></li><li><p>通过链接器（Linker）将不同编译单元（<code>.cpp</code> 文件）中的函数调用链接到最终的函数定义。</p></li></ul></li><li><p><strong><code>vec3.h</code> 的做法 (Header-Only)</strong>:</p><ul><li><p><strong>声明和定义</strong>都放在头文件 (<code>.h</code>) 中。</p></li><li><p>使用 <code>inline</code> 关键字（或在类定义内部实现函数，这会使其隐式内联）来告诉编译器，这个函数的定义可能会在多个编译单元中出现，并且建议在调用处直接展开代码，而不是进行传统的函数调用。</p></li></ul></li></ol><h3 id="vec3-h-做法的好处-Header-Only-Inline"><a href="#vec3-h-做法的好处-Header-Only-Inline" class="headerlink" title="vec3.h 做法的好处 (Header-Only &#x2F; Inline)"></a><strong><code>vec3.h</code> 做法的好处 (Header-Only &#x2F; Inline)</strong></h3><h4 id="1-性能优化：消除函数调用开销"><a href="#1-性能优化：消除函数调用开销" class="headerlink" title="1. 性能优化：消除函数调用开销"></a>1. 性能优化：消除函数调用开销</h4><p>这是 <code>vec3.h</code> 采用这种风格最主要的原因。</p><ul><li><p><strong>函数调用开销</strong>: 每次调用一个普通函数，CPU都需要保存当前执行位置、传递参数、跳转到函数地址、执行函数、然后返回。对于像向量的加法、点乘这样简单且频繁调用的操作，这些开销累加起来会影响性能。</p></li><li><p><strong>内联 (Inlining)</strong>: <code>inline</code> 关键字建议编译器将函数体直接嵌入到调用它的地方。这样就没有了函数调用的开销。对于 <code>vec3 u, v, w; w = u + v;</code> 这样的代码，内联后可能就直接被编译成几条高效的汇编指令，如同你直接写 <code>w.x = u.x + v.x; ...</code> 一样。在图形学和光线追踪这类计算密集型应用中，这种优化至关重要。</p></li></ul><h4 id="2-避免链接错误-Linker-Errors"><a href="#2-避免链接错误-Linker-Errors" class="headerlink" title="2. 避免链接错误 (Linker Errors)"></a>2. 避免链接错误 (Linker Errors)</h4><ul><li><p>如果你尝试把一个普通函数（非 <code>inline</code>）的完整定义放在头文件中，而这个头文件又被多个 <code>.cpp</code> 文件包含，链接器在链接时会发现这个函数有多个定义，从而报错（”multiple definition” error）。</p></li><li><p><code>inline</code> 关键字的一个重要作用就是解决这个问题。它告诉链接器：“这个函数在多个地方都有定义是正常的，你只需要其中一个就行了。” 这使得将函数实现放在头文件中成为可能。</p></li><li><p>不过，如果是像<code>Vector3f</code>那样组织，头文件只有函数的声明，哈数具体实现被单独分到一个文件。就不会出现这样的问题。</p></li></ul><h4 id="3-易于分发和使用"><a href="#3-易于分发和使用" class="headerlink" title="3. 易于分发和使用"></a>3. 易于分发和使用</h4><p>像 <code>vec3.h</code> 这样的库被称为“仅头文件库 (Header-only library)”。开发者只需要 <code>#include</code> 这一个文件就可以使用整个库，不需要复杂的项目配置来链接额外的 <code>.cpp</code> 文件或库文件 (<code>.lib</code>, <code>.a</code>)。这对于小型的、通用的工具类（如数学库）来说非常方便。</p><h3 id="Vector3f做法的好处-Separate-Files"><a href="#Vector3f做法的好处-Separate-Files" class="headerlink" title="Vector3f做法的好处 (Separate Files)"></a><strong>Vector3f做法的好处 (Separate Files)</strong></h3><p>这是C++项目管理中的标准实践，尤其适用于大型项目。它同样有很多优点。</p><h4 id="1-编译速度更快"><a href="#1-编译速度更快" class="headerlink" title="1. 编译速度更快"></a>1. 编译速度更快</h4><ul><li><p>当实现放在 <code>.cpp</code> 文件中时，如果只修改了 <code>.cpp</code> 文件的内容（比如函数的一个实现细节），那么只有这个 <code>.cpp</code> 文件需要重新编译。其他包含了对应头文件的文件则不需要。</p></li><li><p>反观 Header-only 的做法，任何对头文件中函数实现的修改，都会导致所有包含了这个头文件的 <code>.cpp</code> 文件被重新编译，这在大型项目中会极大地拖慢编译速度。</p></li></ul><h4 id="2-更好的代码组织和封装"><a href="#2-更好的代码组织和封装" class="headerlink" title="2. 更好的代码组织和封装"></a>2. 更好的代码组织和封装</h4><ul><li><p><strong>关注点分离</strong>: 将接口（API）的声明放在头文件中，将实现细节放在源文件中，是一种非常清晰的组织方式。当其他人想使用你的类时，他们只需要看头文件，而不需要关心具体的实现。</p></li><li><p><strong>隐藏实现</strong>: 你不希望类的使用者知道或依赖于你的内部实现。这种分离有助于实现信息隐藏（Information Hiding）。</p></li></ul><h3 id="关于运算符重载和友元函数"><a href="#关于运算符重载和友元函数" class="headerlink" title="关于运算符重载和友元函数"></a><strong>关于运算符重载和友元函数</strong></h3><ul><li><p>我们来对比一下：</p></li><li><p><strong>Vector3f实现</strong>: 在 <code>Vector3f</code> 中，像 <code>operator+</code> 这样的二元运算符被实现为<strong>成员函数</strong>。</p></li><li><p><strong><code>vec3.h</code> 的实现</strong>: <code>operator+</code> 被实现为一个<strong>非成员的内联函数</strong> <code>inline vec3 operator+(const vec3 &amp;u, const vec3 &amp;v)</code>。</p></li></ul><p>将二元运算符（如 <code>+</code>, <code>*</code> 等）实现为<strong>非成员函数（通常是 <code>inline</code>，有时是 <code>friend</code>）</strong>是更常见且更灵活的做法。主要原因在于它支持更对称的类型转换。</p><p>例如，在 vec3.h 中，你可以写 2.0 * v，编译器会自动调用 operator*(double t, const vec3 &amp;v)。</p><p>但在你的实现中，你重载的是 Vector3f Vector3f::operator*(float n)，这意味着只有 v * 2.0f 是合法的，而 2.0f * v 会编译失败，所以在<code>Vector3f</code>中不得不提供一个非成员的 operator*（通常可以是友元 friend 函数，如果需要访问私有成员的话）去实现2.0f * v这样的情况。</p><h3 id="总结：为什么要这样做？"><a href="#总结：为什么要这样做？" class="headerlink" title="总结：为什么要这样做？"></a><strong>总结：为什么要这样做？</strong></h3><p>原作者选择 <strong>Header-only 和 <code>inline</code></strong> 的方式，主要是出于以下考虑：</p><ol><li><p><strong>性能 (Performance)</strong>: 对于一个基础数学向量类，性能是第一位的。内联可以显著减少函数调用开销，对计算密集型程序（如光线追踪）非常关键。</p></li><li><p><strong>便利性 (Convenience)</strong>: 作为一个小而美的工具类，做成仅头文件的形式让它更容易被集成到任何项目中。</p></li></ol><p>而Vector3f的做法（分离 <code>.h</code> 和 <code>.cpp</code>）在以下方面更有优势：</p><ol><li><p><strong>可维护性 (Maintainability)</strong>: 在大型项目中，清晰的接口与实现分离、更快的增量编译速度，使得项目更容易管理。</p></li><li><p><strong>封装 (Encapsulation)</strong>: 更好地隐藏实现细节。</p></li></ol><p>总而言之，两种方法没有绝对的对错，而是服务于不同目标的**设计选择 (Design Trade-off)**。对于像 <code>vec3</code> 这样小、稳定、性能要求高的基础工具类，Header-only 的 <code>inline</code> 实现是业界的常见选择。对于更复杂的、业务逻辑相关的类，分离文件是更稳妥、更具扩展性的方案。</p><hr><h3 id="内联与友元"><a href="#内联与友元" class="headerlink" title="内联与友元"></a>内联与友元</h3><ul><li>我们来深入探讨一下<code>内联函数 (inline function)</code>，并把它和<code>友元函数 (friend function)</code>进行清晰的区分。</li><li>其实这两个是截然不同的概念，互相并不矛盾，也可以结合使用。放在一起纯粹是因为两种不同的运算符重载方案分别使用了内联函数方案和友元函数方案，且考虑的出发点也不同。</li></ul><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><ul><li><code>inline</code> 关键字的核心目标是<strong>向编译器提出一个性能优化的建议</strong>。</li></ul><h4 id="主要目的：消除函数调用开销"><a href="#主要目的：消除函数调用开销" class="headerlink" title="主要目的：消除函数调用开销"></a>主要目的：消除函数调用开销</h4><ul><li>当你调用一个普通函数时，程序会执行一系列的“幕后”操作：</li></ul><ol><li><p>将当前指令的地址入栈（以便知道函数执行完后返回哪里）。</p></li><li><p>将函数参数复制到栈上。</p></li><li><p>跳转到函数的内存地址。</p></li><li><p>执行函数体。</p></li><li><p>将返回值（如果有）放到指定位置。</p></li><li><p>从栈中恢复指令地址，跳回原来的地方继续执行。</p></li></ol><ul><li>这个过程被称为“函数调用开销 (function call overhead)”。对于大多数函数来说，这点开销微不足道。但如果一个函数非常小（比如只有一两行代码）且被极其频繁地调用（例如，在一个百万次循环中），这个开销就会累积起来，影响程序的整体性能。</li><li><code>inline</code> 就是为了解决这个问题。将一个函数声明为 <code>inline</code> 时，其实是在建议编译器：<strong>“请不要生成函数调用指令，而是直接把这个函数的代码‘复制粘贴’到调用它的地方吧。”</strong></li><li>这个过程被称为**内联展开 (inlining)**。</li></ul><p><strong>代码示例:</strong></p><p>C++</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 声明一个内联函数</span><br><span class="hljs-function">inline <span class="hljs-built_in">int</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">some_function</span>()</span> &#123;<br>    <span class="hljs-built_in">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-built_in">int</span> result = <span class="hljs-keyword">add</span>(x, y); <span class="hljs-comment">// 编译器可能会把这里替换成 int result = x + y;</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>内联展开后，<code>some_function</code> 在编译期间看起来就像这样，完全没有了 <code>add</code> 函数的调用过程：</p><p>C++</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">some_function</span>()</span> &#123;<br>    <span class="hljs-built_in">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-built_in">int</span> result = x + y; <span class="hljs-comment">// 直接嵌入，没有函数调用开销</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="inline-的两个关键点"><a href="#inline-的两个关键点" class="headerlink" title="inline 的两个关键点"></a><code>inline</code> 的两个关键点</h4><ol><li><p><strong>它仅仅是个建议</strong>：<code>inline</code> 关键字不是强制命令。编译器会自行判断是否进行内联。如果一个函数太长、包含循环或递归，编译器通常会忽略 <code>inline</code> 建议，依然将其作为普通函数来调用。</p></li><li><p>解决头文件中的“多重定义”问题：这是 inline 一个非常重要的、实际的用途。如果你把一个函数的完整定义放在头文件(.h)中，而这个头文件被多个源文件(.cpp)包含，链接器(linker)在最后链接时会发现这个函数有多个定义，从而导致<strong>“多重定义 (multiple definition)”</strong>的链接错误。</p><p> inline 关键字可以解决这个问题。它告诉链接器：“这个函数在多个地方都有定义是合法的，它们都是同一个函数，你只需要保留一个副本就行了。” 这也是为什么像 vec3.h 这样的仅头文件库(Header-only library)能成功的原因。</p></li></ol><hr><h3 id="详细介绍友元函数-friend"><a href="#详细介绍友元函数-friend" class="headerlink" title="详细介绍友元函数 (friend)"></a><strong>详细介绍友元函数 (<code>friend</code>)</strong></h3><p><code>friend</code> 关键字的核心目标是<strong>打破类的封装性，提供一种受控的外部访问机制</strong>。</p><h4 id="主要目的：访问类的私有成员"><a href="#主要目的：访问类的私有成员" class="headerlink" title="主要目的：访问类的私有成员"></a>主要目的：访问类的私有成员</h4><ul><li>C++ 的核心思想之一是**封装 (Encapsulation)**，即把数据（成员变量）和操作数据的方法（成员函数）捆绑在一起，并对外部隐藏数据的实现细节。通过 <code>public</code>, <code>protected</code>, <code>private</code> 关键字，我们可以控制谁能访问类的成员。</li><li><code>private</code> 成员通常只能被这个类自己的成员函数访问。但是，在某些特殊情况下，一个<strong>非成员函数</strong>或者<strong>另一个类</strong>需要直接访问这个类的私有成员。这时，就可以在类定义内部使用 <code>friend</code> 关键字，“授权”那个函数或类成为自己的“朋友”。</li><li><strong>一个“朋友”可以访问该类的 <code>private</code> 和 <code>protected</code> 成员，就像它是这个类的成员函数一样。</strong>。<br><strong>代码示例:</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> x, y, z;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Vector</span>(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">double</span> z) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y), <span class="hljs-built_in">z</span>(z) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明 operator&lt;&lt; 为友元函数</span><br>    <span class="hljs-comment">// 它不是成员函数，但可以访问 Vector 的 private 成员</span><br>    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="hljs-type">const</span> Vector&amp; v);<br>&#125;;<br><br><span class="hljs-comment">// 友元函数的定义（在类外部）</span><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="hljs-type">const</span> Vector&amp; v) &#123;<br>    <span class="hljs-comment">// 因为是 friend，所以这里可以直接访问 v.x, v.y, v.z</span><br>    out &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; v.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; v.z &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Vector <span class="hljs-title">my_vec</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;My vector is: &quot;</span> &lt;&lt; my_vec &lt;&lt; std::endl; <span class="hljs-comment">// 可以正常工作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果没有 <code>friend</code> 声明，<code>operator&lt;&lt;</code> 函数就无法访问 <code>my_vec</code> 的私有成员 <code>x</code>, <code>y</code>, <code>z</code>，代码将无法编译。</li></ul><hr><h3 id="inline-和-friend-的核心区别"><a href="#inline-和-friend-的核心区别" class="headerlink" title="** inline 和 friend 的核心区别**"></a>** <code>inline</code> 和 <code>friend</code> 的核心区别**</h3><table><thead><tr><th>特性</th><th>内联函数 (<code>inline</code>)</th><th>友元函数 (<code>friend</code>)</th></tr></thead><tbody><tr><td><strong>主要目的</strong></td><td><strong>性能优化</strong></td><td><strong>访问控制</strong></td></tr><tr><td><strong>解决的问题</strong></td><td>减少函数调用开销；避免头文件中的多重定义链接错误。</td><td>允许非成员函数或另一个类访问本类的 <code>private</code>&#x2F;<code>protected</code> 成员。</td></tr><tr><td><strong>作用对象</strong></td><td>函数的<strong>实现方式</strong>。</td><td>函数或类的<strong>访问权限</strong>。</td></tr><tr><td><strong>本质</strong></td><td>对编译器的<strong>建议</strong>，影响代码如何生成。</td><td>对编译器的<strong>规则</strong>，打破封装，授予访问权。</td></tr><tr><td><strong>关键字位置</strong></td><td>在函数<strong>定义或声明</strong>时使用。</td><td>在<strong>类定义内部</strong>，用于声明谁是“朋友”。</td></tr></tbody></table><p><strong>总结一句话：<code>inline</code> 关心代码“如何”执行，<code>friend</code> 关心“谁能”访问数据。</strong> 它们是两个完全正交（不相关）的概念。</p><h3 id="结合使用-inline-和-friend"><a href="#结合使用-inline-和-friend" class="headerlink" title="结合使用 inline 和 friend"></a><strong>结合使用 <code>inline</code> 和 <code>friend</code></strong></h3><ul><li><p>回到上面的 <code>Vector</code> 和 <code>operator&lt;&lt;</code> 的例子。如果我们想把 <code>operator&lt;&lt;</code> 的实现也放在头文件中（为了方便），我们就必须把它标记为 <code>inline</code> 以防止多重定义错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在头文件 Vector.h 中</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> &#123;<br>    <span class="hljs-comment">// ... private members ...</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ... public members ...</span><br>    <br>    <span class="hljs-comment">// 声明 operator&lt;&lt; 为友元</span><br>    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="hljs-type">const</span> Vector&amp; v);<br>&#125;;<br><br><span class="hljs-comment">// 将友元函数的定义也放在头文件中，必须标记为 inline</span><br><span class="hljs-keyword">inline</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="hljs-type">const</span> Vector&amp; v) &#123;<br>    out &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; v.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; v.z &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在这里：</p><ul><li><code>friend</code> 授予了 <code>operator&lt;&lt;</code> 访问 <code>Vector</code> 私有成员的<strong>权限</strong>。</li><li><code>inline</code> 解决了将这个函数定义放在头文件里可能导致的<strong>链接错误</strong>，并可能带来性能提升。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>cs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>面向对象</tag>
      
      <tag>cg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从实现一个Vector3f向量类，深入了解运算符重载</title>
    <link href="/2025/07/22/%E4%BB%8E%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAVector3f%E5%90%91%E9%87%8F%E7%B1%BB%EF%BC%8C%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <url>/2025/07/22/%E4%BB%8E%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAVector3f%E5%90%91%E9%87%8F%E7%B1%BB%EF%BC%8C%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p><strong>练习 A：实现一个 <code>Vector3f</code>向量类。</strong></p></li><li><p><strong>目标：</strong> 这是图形学编程的“Hello World”。</p></li><li><p><strong>要求：</strong> 创建一个 <code>Vector3f.h</code>和 <code>.cpp</code>，类中包含 <code>float x, y, z;</code>三个成员。您需要为它实现：</p><ol><li>构造函数（<code>Vector3f(float x, float y, float z)</code>）。</li><li>成员函数，如计算向量长度 <code>length()</code>和归一化 <code>normalize()</code>。</li><li><strong>操作符重载(Operator Overloading)：</strong> 实现向量的加法 (<code>+</code>)、减法 (<code>-</code>)、与标量的乘法 (<code>*</code>)。这是 C++在图形学中应用极广的特性。</li></ol></li></ul><hr><h2 id="实现与思考过程"><a href="#实现与思考过程" class="headerlink" title="实现与思考过程"></a>实现与思考过程</h2><h3 id="前期思考"><a href="#前期思考" class="headerlink" title="前期思考"></a>前期思考</h3><ul><li>首先要明确，一个向量类到底有哪些基础的属性，方法，向量的运算法则有哪些。这里已经给出了 <code>float x, y, z</code>三个成员，顺着这个思路，选用标准正交基，并且表示为(x,y,z）的形式（这在后面打印时会用到）。回想数学课中学到的向量的基本运算，有加、减、数乘、点乘、叉乘。实现这些运算法则需要我们自己实现操作符的重载。</li><li>成员函数方面，除了问题中提到的计算向量长度 <code>length()</code>和归一化 <code>normalize()</code><em>（归一化，可以简单的理解为将向量化为单位向量，但是归一化这一概念，在机器学习领域中有更深刻的含义）</em>,我在这里增加了个 print 的成员函数，用于美观地打印向量值，方便测试。</li></ul><h3 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h3><ul><li><strong>总结一下，大致这个 Vector3f 的类的成员函数，成员有这些</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Point.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector3f</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//这里存放了类的构建函数和析构函数</span><br>    <span class="hljs-built_in">Vector3f</span>(<span class="hljs-type">void</span>);<br><span class="hljs-comment">/*这里我又构建了另一个Point类，表示三维坐标系上的点，这个函数构建以start_point为起点，end_point为终点的向。</span><br><span class="hljs-comment">Point类一些运算法则和Vector3f其实是一样的。话说回来，点有加减这样的运算法则码，称其为以(0,0)为起点的向量更合适。*/</span><br>    <span class="hljs-built_in">Vector3f</span>(<span class="hljs-type">const</span> Point &amp;, <span class="hljs-type">const</span> Point &amp;);<br><br>    <span class="hljs-built_in">Vector3f</span>(<span class="hljs-type">float</span>, <span class="hljs-type">float</span>, <span class="hljs-type">float</span>);<br><br>    <span class="hljs-built_in">Vector3f</span>(<span class="hljs-type">const</span> Vector3f &amp;);<br><br>    ~<span class="hljs-built_in">Vector3f</span>(<span class="hljs-type">void</span>);<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">length</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br>    <span class="hljs-function">Vector3f &amp;<span class="hljs-title">normalize</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br>    Vector3f &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Vector3f &amp;);<br><br>    Vector3f &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Vector3f &amp;);<br><br>    Vector3f <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Vector3f &amp;);<br><br>    Vector3f &amp;<span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> Vector3f &amp;);<br><br>    Vector3f <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Vector3f &amp;);<br><br>    <span class="hljs-comment">// 用来表示点乘</span><br>    <span class="hljs-type">float</span> <span class="hljs-keyword">operator</span>^(<span class="hljs-type">const</span> Vector3f &amp;);<br><br>    <span class="hljs-comment">// 数乘</span><br>    Vector3f <span class="hljs-keyword">operator</span>*(<span class="hljs-type">float</span>);<br><br>    <span class="hljs-comment">// 叉乘</span><br>    Vector3f <span class="hljs-keyword">operator</span>%(<span class="hljs-type">const</span> Vector3f &amp;);<br>    <span class="hljs-comment">/*“为了探索运算符重载的各种可能性，我在这里将`^`和`%`分别重载为点乘和叉乘。但在团队协作或开源项目中，为了代码的清晰易读，通常会使用**具名函数**，如`dot()`和`cross()`*/</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">float</span> x, y, z;<br>&#125;;<br>&#125;```<br>- 具体实现如下<br>```c++<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Vector3f.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-comment">// 默认生成零向量</span><br>Vector3f::<span class="hljs-built_in">Vector3f</span>(<span class="hljs-type">void</span>) : <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">z</span>(<span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br><br><br>Vector3f::<span class="hljs-built_in">Vector3f</span>(<span class="hljs-type">const</span> Point &amp;start_point, <span class="hljs-type">const</span> Point &amp;end_point)<br>&#123;<br>    x = (end_point - start_point).<span class="hljs-built_in">getX</span>();<br><br>    y = (end_point - start_point).<span class="hljs-built_in">getY</span>();<br><br>    z = (end_point - start_point).<span class="hljs-built_in">getZ</span>();<br>&#125;<br><br>Vector3f::<span class="hljs-built_in">Vector3f</span>(<span class="hljs-type">const</span> Vector3f &amp;vector)<br>&#123;<br>    *<span class="hljs-keyword">this</span> = vector;<br>&#125;<br><br>Vector3f::<span class="hljs-built_in">Vector3f</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> z) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y), <span class="hljs-built_in">z</span>(z)<br>&#123;<br>&#125;<br>Vector3f::~<span class="hljs-built_in">Vector3f</span>(<span class="hljs-type">void</span>)<br>&#123;<br>&#125;<br><br><br>Vector3f &amp;Vector3f::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Vector3f &amp;right)<br><br>&#123;<br>    x = right.x;<br>    y = right.y;<br>    z = right.z;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>Vector3f &amp;Vector3f::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Vector3f &amp;right)<br>&#123;<br>    x += right.x;<br>    y += right.y;<br>    z += right.z;<br>   <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>Vector3f Vector3f::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Vector3f &amp;right)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector3f</span>(x + right.x, y + right.y, z + right.z);<br>&#125;<br><br>Vector3f &amp;Vector3f::<span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> Vector3f &amp;right)<br>&#123;<br>   x -= right.x;<br>    y -= right.y;<br>    z -= right.z;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>Vector3f Vector3f::<span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Vector3f &amp;right)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector3f</span>(x - right.x, y - right.y, z - right.z);<br>&#125;<br>Vector3f Vector3f::<span class="hljs-keyword">operator</span>*(<span class="hljs-type">float</span> n)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector3f</span>(n * x, n * y, n * z);<br>&#125;<br><span class="hljs-type">float</span> Vector3f::<span class="hljs-keyword">operator</span>^(<span class="hljs-type">const</span> Vector3f &amp;right)<br>&#123;<br>    <span class="hljs-type">float</span> x_result = x * right.x;<br>    <span class="hljs-type">float</span> y_result = y * right.y;<br>    <span class="hljs-type">float</span> z_result = z * right.z;<br>    <span class="hljs-keyword">return</span> (x_result + y_result + z_result);<br>&#125;<br><br>Vector3f Vector3f::<span class="hljs-keyword">operator</span>%(<span class="hljs-type">const</span> Vector3f &amp;right)<br>&#123;<br>    <span class="hljs-type">float</span> new_x = y * right.z - right.y * z;<br>    <span class="hljs-type">float</span> new_y = -(x * right.z - right.x * z);<br>    <span class="hljs-type">float</span> new_z = x * right.y - right.x * y;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector3f</span>(new_x, new_y, new_z);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Vector3f::print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; z &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Vector3f::length</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">sqrt</span>(x * x + y * y + z * z);<br>&#125;<br><br><span class="hljs-function">Vector3f&amp; <span class="hljs-title">Vector3f::normalize</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">float</span> len = <span class="hljs-built_in">length</span>();<span class="hljs-comment">//只用计算一次长度</span><br>    <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 防止除以零</span><br>        x /= len;<br>        y /= len;<br>        z /= len;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h4><h5 id="1-成员函数的排放顺序"><a href="#1-成员函数的排放顺序" class="headerlink" title="1. 成员函数的排放顺序"></a>1. 成员函数的排放顺序</h5><ul><li>将公共的接口放在前面，私有的成员放在后面。这种习惯在实际开发中方便对接人员找到接口。</li></ul><h5 id="2-带-号的，返回类型加上"><a href="#2-带-号的，返回类型加上" class="headerlink" title="2. 带&#x3D;号的，返回类型加上&amp;"></a>2. <strong>带&#x3D;号的，返回类型加上&amp;</strong></h5><ul><li><p>第一个  &amp;：Vector3f &amp; (作为函数返回值)</p></li><li><p><strong>含义</strong>：这里的  Vector3f &amp;  定义了  operator&#x3D;  函数的<strong>返回类型</strong>。它意味着这个函数将返回一个  Vector3f  对象的<strong>引用</strong>。</p></li><li><p><strong>目的</strong>：返回引用的主要目的是实现**链式赋值 (chaining assignment)**。例如，你可以写出这样的代码： &#96;&#96;&#96;<br>Vector3f a, b, c;<br>a &#x3D; b &#x3D; c;</p></li><li><p>这段代码会被解析为  a.operator&#x3D;(b.operator&#x3D;(c))。为了让  a.operator&#x3D;  能够执行，b.operator&#x3D;(c)  必须返回一个可以被赋值的对象，也就是  b  自身。通过返回  <em>this  的引用（</em>this  代表调用该成员函数的对象本身），b &#x3D; c  的结果就是  b  自身的引用，然后这个引用可以继续用于对  a  的赋值</p></li><li><p>假如不返回对象的引用呢？</p></li><li><p>会造成如下几个问题</p><ol><li><strong>链式赋值 (a &#x3D; b &#x3D; c) 的工作机制变得低效且不符合预期。</strong></li><li><strong>会产生不必要的对象复制，导致严重的性能开销。</strong></li><li><strong>违反了 C++ 的核心设计惯例，使代码难以理解和维护</strong></li></ol></li><li><p>举例</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">Vector3f Vector3f::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Vector3f &amp;right)<br>&#123;<br>    x += right.x;<br>    y += right.y;<br>    z += right.z;<br>   <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>考虑以下链式调用：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Vector3f <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">Vector3f <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-comment">// 目标：将a和b相加，然后将结果（新的a）单位化</span><br>(a += b).<span class="hljs-built_in">normalize</span>();<br></code></pre></td></tr></table></figure><ol><li><p>影响一：不必要的对象复制和性能开销</p><p>当写下  return *this;  时，编译器会检查函数的返回类型。</p><ul><li><strong>错误实现 (Vector3f)<strong>：返回类型是  Vector3f，一个值。编译器会调用  Vector3f  的拷贝构造函数，创建一个  *this  的</strong>临时副本</strong>，然后将这个副本返回。</li><li>**正确实现 (Vector3f&amp;)**：返回类型是  Vector3f&amp;，一个引用。编译器只会返回  *this  的别名（本质上是一个地址），不会创建任何新对象。</li><li><strong>后果是什么？</strong></li></ul><p>对于一个简单的语句  v1 +&#x3D; v2;：</p><ol><li>v1  的值被正确更新 (x, y, z 都加上了  v2  相应的值)。</li><li>函数返回了一个  v1  的临时副本。</li><li>因为这个返回值没有被用在任何地方，所以这个临时副本马上就被销毁了。</li></ol><p>在这个简单场景下，代码的功能<strong>表面上看起来是正确的</strong>，但你为一次毫无用处的对象复制和销毁付出了性能代价。对于  Vector3f  这样的小对象，代价很小；但对于管理大量资源的类，代价将是巨大的。</p></li><li><p>影响二：链式调用的行为错误 (这是一个更严重的 BUG)</p><p>这是返回值为值时最危险的陷阱。假设你的  Vector3f  类还有一个方法，比如  normalize()，用于将向量单位化。<br>让我们分析两种实现下这行代码的行为：</p><p><strong>1. 当  operator+&#x3D;  返回  Vector3f (错误版本)</strong></p><ul><li>a +&#x3D; b  被执行。a  的值变成了  (3, 0, 0)。</li><li>operator+&#x3D;  返回了一个  a  的<strong>临时副本</strong>。这个副本的值也是  (3, 0, 0)。</li><li>.normalize()  方法被调用，但它是作用在这个<strong>临时副本</strong>上的！</li><li>临时副本被单位化，它的值变成了  (1, 0, 0)。</li><li>这行代码执行完毕后，临时副本被销毁。</li><li>最终  a  的值仍然是  (3, 0, 0)，它根本没有被  normalize()  影响到。这是一个非常隐蔽且危险的逻辑错误。</li></ul><p><strong>2. 当  operator+&#x3D;  返回  Vector3f&amp; (正确版本)</strong></p><ul><li>a +&#x3D; b  被执行。a  的值变成了  (3, 0, 0)。</li><li>operator+&#x3D;  返回了<strong>一个指向  a  自身的引用</strong>。</li><li>.normalize()  方法通过这个引用，被直接调用在  a  对象上。</li><li>a  被成功单位化。</li><li>最终  a  的值变成了  (1, 0, 0)。这完全符合预期。</li></ul></li></ol><ul><li><p><strong>核心准则：</strong>  对于所有会修改对象自身状态的复合赋值运算符 (+&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;, &#x3D;)，都应该返回  *this  的引用 (ClassName&amp;)。</p></li><li><p>但是 二元算术运算符 (+, -, *, &#x2F;)：不修改自身，应返回一个新对象 (ClassName) 来存储结果。通常实现为创建一个左操作数 (*this) 的副本。这个副本将作为结果返回。可利用非成员函数或  const  成员函数，并基于对应的复合赋值运算符来构建。</p><ul><li>这类运算符的核心语义是：计算两个操作数的和，并返回这个和作为一个<strong>全新的值</strong>，而<strong>不改变任何一个原始操作数</strong>。</li><li>因此，不能返回一个已存在的对象的引用。这个对象不能是左操作数（因为我们不能修改它），也不能是右操作数。那么唯一的可能是函数内部创建的局部变量。但是局部变量在函数执行结束后就会被销毁。</li><li>同样的，不能出现函数内部用*this+&#x3D;right 去实现+运算这种情况，因为这样会改变左操作数的值 &#96;&#96;&#96;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 注意函数末尾的 const，表示这个函数不会修改 \*this 对象</span><br>Vector3f  Vector3f::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Vector3f &amp;right) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-comment">// 1. 创建一个左操作数 (\*this) 的副本。这个副本将作为结果返回。</span><br>    Vector3f result = \*<span class="hljs-keyword">this</span>;<br>    <span class="hljs-comment">// 2. 使用已经实现的 operator+= 来修改这个副本。</span><br>    result += right; <span class="hljs-comment">// 等价于 result.operator+=(right);</span><br>    <span class="hljs-comment">// 3. 按值返回这个被修改后的副本。</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这是除前面给出外的另一种实现方法</li></ul></li></ul><h6 id="补充：-符号在-C-中的基本含义"><a href="#补充：-符号在-C-中的基本含义" class="headerlink" title="补充：&amp;  符号在 C++ 中的基本含义"></a>补充：&amp;  符号在 C++ 中的基本含义</h6><ul><li>在 C++ 中，&amp;  符号根据上下文有多种含义：</li><li>**取地址运算符 (Address-of operator)**：当用在变量名前时（如  &amp;myVar），它会返回该变量的内存地址。</li><li>**按位与运算符 (Bitwise AND operator)**：当用在两个整数之间时，它执行按位与操作。</li><li>**引用声明 (Reference declarator)**：当用在类型名之后时（如  int&amp;），它声明一个引用。</li></ul><h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>特性</td><td>Vector3f&amp; operator+&#x3D; (返回引用 -<strong>正确</strong>)</td><td>Vector3f operator+&#x3D; (返回值 -<strong>错误</strong>)</td></tr><tr><td><strong>基本操作  a +&#x3D; b;</strong></td><td>a 被修改。高效。</td><td>a 被修改。但创建了一个无用的临时返回值，有性能开销。</td></tr><tr><td><strong>链式操作  (a +&#x3D; b).normalize();</strong></td><td>a 被修改，然后 a 被 normalize。<strong>行为正确</strong>。</td><td>a 被修改，但 normalize 作用于一个临时副本上，a 本身未变。<strong>行为错误</strong>。</td></tr><tr><td><strong>性能</strong></td><td><strong>极高</strong>，无复制开销。</td><td><strong>较低</strong>，每次调用都有不必要的对象复制和销毁开销。</td></tr><tr><td><strong>惯例</strong></td><td>符合 C++标准库和内置类型的行为。</td><td>违反惯例，可能导致意外的、难以调试的 bug。</td></tr></tbody></table><h5 id="3-如何实现”n-vec”？"><a href="#3-如何实现”n-vec”？" class="headerlink" title="3. 如何实现”n*vec”？"></a>3. 如何实现”n*vec”？</h5><ul><li>正如前言所说，操作符(operator)，可以被翻译为 a.operator(x);</li><li>当我要实现 Vector*float，编译器会将其解释为： vec.operator*(n) ，这是一个对  vec  对象的成员函数调用，这是可行的。</li><li>但是，对于 n * vec，编译器会尝试将其解释为： <code>n.operator\*(vec)</code> 这里的  n  是一个  float，是 C++ 的内置类型。你不能给  float  添加成员函数  operator*，所以这种方式从根本上就行不通。</li></ul><h6 id="解决方案：使用非成员函数（自由函数）"><a href="#解决方案：使用非成员函数（自由函数）" class="headerlink" title="解决方案：使用非成员函数（自由函数）"></a>解决方案：使用非成员函数（自由函数）</h6><ul><li>要实现  n * vec，你需要将  operator*  重载为一个<strong>非成员函数（non-member function）</strong>，也叫自由函数或全局函数。</li><li>当编译器看到  n * vec  时，如果它无法在  float  类型中找到成员函数，它就会去查找一个可以接受一个  float  和一个  Vector3f  作为参数的全局  operator*  函数。</li></ul><h6 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h6><ul><li>你需要做两件事：<ol><li><strong>保留你的成员函数</strong>  用于处理  vec * n。</li><li><strong>新增一个非成员函数</strong>  用于处理  n * vec。</li></ol></li></ul><p>为了让这个非成员函数能够访问  Vector3f  的私有成员（如  x, y, z），你还需要在类定义中将其声明为**友元 (friend)**。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector3f</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">float</span> x, y, z;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Vector3f</span>(<span class="hljs-type">float</span> x = <span class="hljs-number">0.0f</span>, <span class="hljs-type">float</span> y = <span class="hljs-number">0.0f</span>, <span class="hljs-type">float</span> z = <span class="hljs-number">0.0f</span>);<br><br>    <span class="hljs-comment">// 1. 成员函数版本，用于处理 vec * n</span><br>    Vector3f <span class="hljs-keyword">operator</span>*(<span class="hljs-type">float</span> s) <span class="hljs-type">const</span>;<br><br>    <span class="hljs-comment">// 2. 将非成员函数声明为友元，以允许它访问私有成员</span><br>    <span class="hljs-comment">//    这个函数用于处理 n * vec</span><br>    <span class="hljs-keyword">friend</span> Vector3f <span class="hljs-keyword">operator</span>*(<span class="hljs-type">float</span> s, <span class="hljs-type">const</span> Vector3f&amp; vec);<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>具体实现</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Vector3f.h&quot;</span></span><br><br>Vector3f::<span class="hljs-built_in">Vector3f</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> z) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y), <span class="hljs-built_in">z</span>(z) &#123;&#125;<br><br><span class="hljs-comment">// 1. 成员函数 operator* 的实现 (vec * n)</span><br><span class="hljs-comment">//    注意末尾的 const，表示这个操作不应该修改原始向量 vec</span><br>Vector3f Vector3f::<span class="hljs-keyword">operator</span>*(<span class="hljs-type">float</span> s) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector3f</span>(<span class="hljs-keyword">this</span>-&gt;x * s, <span class="hljs-keyword">this</span>-&gt;y * s, <span class="hljs-keyword">this</span>-&gt;z * s);<br>&#125;<br><br><span class="hljs-comment">// 2. 非成员函数 operator* 的实现 (n * vec)</span><br><span class="hljs-comment">//    这个函数不属于任何类，所以没有 Vector3f:: 前缀</span><br>Vector3f <span class="hljs-keyword">operator</span>*(<span class="hljs-type">float</span> s, <span class="hljs-type">const</span> Vector3f&amp; vec)<br>&#123;<br>    <span class="hljs-comment">// 最优雅的实现方式是直接调用我们已经写好的成员函数版本，</span><br>    <span class="hljs-comment">// 以避免重复代码。因为乘法满足交换律。</span><br>    <span class="hljs-keyword">return</span> vec * s;<br><br>    <span class="hljs-comment">// 或者，你也可以直接实现，因为它是友元，可以访问私有成员：</span><br>    <span class="hljs-comment">// return Vector3f(vec.x * s, vec.y * s, vec.z * s);</span><br>    <span class="hljs-comment">// 但调用现有成员函数是更好的实践。</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>总结：<ol><li><strong>当你的类对象是左操作数时</strong>：优先使用<strong>成员函数</strong>来实现运算符重载（例如  vec * n）。</li><li><strong>当你的类对象是右操作数，且左操作数是内置类型或其他类的对象时</strong>：必须使用<strong>非成员函数</strong>（通常是全局函数）来实现（例如  n * vec）。</li><li><strong>访问权限</strong>：如果非成员函数需要访问类的  private  或  protected  成员，请在类的定义中将其声明为  friend。</li><li><strong>代码重用</strong>：为了保持逻辑一致性并减少代码冗余，通常让非成员函数版本调用成员函数版本来实现其功能（如  return vec * s;）。</li></ol></li></ul><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><ul><li>创建 <code>main.cpp</code>文件，作为自定义类和函数的测试程序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Vector3f.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Vector3f vec1 = <span class="hljs-built_in">Vector3f</span>();<br>    vec<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>();<br>    Vector3f vec2 = <span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    Vector3f vec3 = vec2 * <span class="hljs-number">3</span>;<br>    vec<span class="hljs-number">3.</span><span class="hljs-built_in">print</span>();<br>    Vector3f vec4 = <span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    (vec2 + vec4).<span class="hljs-built_in">print</span>();<br>    (vec2 - vec4).<span class="hljs-built_in">print</span>();<br>    (vec2 % vec4).<span class="hljs-built_in">print</span>();<br>    std::cout &lt;&lt; (vec2 ^ vec3) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; vec<span class="hljs-number">3.l</span>ength() &lt;&lt; std::endl;<br>    vec<span class="hljs-number">3.</span><span class="hljs-built_in">normalize</span>();<br>    vec<span class="hljs-number">3.</span><span class="hljs-built_in">print</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译，调试，修改"><a href="#编译，调试，修改" class="headerlink" title="编译，调试，修改"></a>编译，调试，修改</h3><ul><li>写完后进行编译，这里我选择了用 cmake 编译，关于 cmake 相关内容可以看从手动编译到 CMAKE<br><img src="/img/outputVector3f.png" alt="输出结果如下"></li><li>tips: 在开头代码中没有实现”n*vec”，实际上 main 函数也没有测试这个</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>通过实现这样一个 <code>Vector3f</code>向量类，了解了友元函数，运算符的重载相关的知识点。</li></ul>]]></content>
    
    
    <categories>
      
      <category>cs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>面向对象</tag>
      
      <tag>cg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-x-x-x 形而上学</title>
    <link href="/2025/06/04/2-x-x-x%20%E5%BD%A2%E8%80%8C%E4%B8%8A%E5%AD%A6/"/>
    <url>/2025/06/04/2-x-x-x%20%E5%BD%A2%E8%80%8C%E4%B8%8A%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="2-形而上学（Metaphysics）"><a href="#2-形而上学（Metaphysics）" class="headerlink" title="2-形而上学（Metaphysics）"></a>2-形而上学（Metaphysics）</h1><ul><li><p>场域：冲突</p></li><li><p>本体：</p></li><li><p>现象：</p></li><li><p>目的：</p></li><li><p>如果仅在实在论下，里面不会有任何东西产生，仅仅是秩序的“再生产”，这是无意义的。</p></li><li><p>它的出现是有原因的，是不得不出现的。例如：我是谁（预设了“我”的存在，为什么会有“我”；为什么存在“是”）</p></li></ul><p><strong>三、3-观念论（Idealism）</strong></p><p><strong>场域：中心</strong></p><p><strong>本体：</strong></p><p><strong>现象：</strong></p><p><strong>目的：</strong></p><p>唯心主义，通过我的思想和反思去探索场域的本体、现象和目的，并把握“中心化”的机制。</p><p>例如，笛卡尔、康德、谢林、黑格尔、费希特</p><p><strong>四、4-唯物主义（Materialism）</strong></p><p><strong>场域：虚无</strong></p><p><strong>本体：</strong></p><p>现象：</p><p>目的：</p><p>跳过场域，直接讨论本体，场域是由本体产生的，“我”不相信这背后某种的运行规律在支撑，“我”自己创造all the things。</p><p>这是一个“否定性”的力量，从来没有历史舞台，而只有历史！</p>]]></content>
    
    
    <categories>
      
      <category>ISMISM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哲学</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-x-x-x 实在论</title>
    <link href="/2025/06/04/1-x-x-x%20%E5%AE%9E%E5%9C%A8%E8%AE%BA/"/>
    <url>/2025/06/04/1-x-x-x%20%E5%AE%9E%E5%9C%A8%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>[【一分钟哲学课】 <a href="https://www.bilibili.com/video/BV1cb411U7Gr/?share_source=copy_web&vd_source=97f40a460ffc72e925773fa7edbc0a45%5D">https://www.bilibili.com/video/BV1cb411U7Gr/?share_source=copy_web&amp;vd_source=97f40a460ffc72e925773fa7edbc0a45]</a></p><h2 id="1-1-科学实在论"><a href="#1-1-科学实在论" class="headerlink" title="1- 1 科学实在论"></a>1- 1 科学实在论</h2><h3 id="1-1-1-物理主义"><a href="#1-1-1-物理主义" class="headerlink" title="1-1-1 物理主义"></a>1-1-1 物理主义</h3><ul><li>目的：<ul><li><strong>在以上的基础上，所有的现象也是出自同一秩序，所有的现象都可以用同一套物理定律来解释，问题是为啥是同一套秩序起作用。</strong></li></ul></li></ul><h4 id="1-1-1-1"><a href="#1-1-1-1" class="headerlink" title="1-1-1-1"></a>1-1-1-1</h4><ul><li>世界的目的，整个世界的运行方向是秩序的“再生长”，亲情、爱情都是由物理定律所支配。问题是为啥要盲目坚持这种秩序？一些情况下，对于秩序的追求往往就变成了对于权力的追求</li><li>例如：苏联学阀李森科</li></ul><h4 id="1-1-1-2"><a href="#1-1-1-2" class="headerlink" title="1-1-1-2"></a>1-1-1-2</h4><ul><li><strong>无机 vs 有机，想要挣脱出科学独断论，这代表了人不甘于始终受到一种禁锢和控制，例如：钱学森同志，杨振宁，追求真理、追求民族复兴，支持气功热潮，妄图把握从无机世界中生成的有机的力量，这种力量代表了一个神秘的目的</strong></li></ul><h4 id="1-1-1-3"><a href="#1-1-1-3" class="headerlink" title="1-1-1-3"></a>1-1-1-3</h4><ul><li><strong>物理主义的基础上，世界有一个目的——人类的命运、共同体，当探索前三个秩序的时候最终目的是人的利益，例如：诺贝尔，大部分人收益于此等意识形态，维护人类利益，但是有一些不然，例如《朝闻道》里的丁仪。此外，ta 们往往认为人越多越好。</strong></li></ul><h4 id="1-1-1-4"><a href="#1-1-1-4" class="headerlink" title="1-1-1-4"></a>1-1-1-4</h4><ul><li><strong>宇宙、世界的运行方向就是没有方向，这些秩序没有为目的做任何保障，例如，刘慈欣笔下的叶文洁。代码再怎么跑，硬件怎么办。</strong></li><li>其他举例 一些末日科幻（？</li></ul><h3 id="1-1-2-建构主义"><a href="#1-1-2-建构主义" class="headerlink" title="1-1-2 建构主义"></a>1-1-2 建构主义</h3><ul><li>场域：秩序</li><li>本体：秩序</li><li>现象：冲突</li><li>目的：</li><li><strong>被理工科知识分子所说服的人文知识分子，ta 们想要抢夺回一些被理工科知识分子占有的话语权。如果按照科学独断论所行进，那么必定会有一个荒谬的结果。科学和社会之间存在隔阂。例如瑞士心里学家皮亚杰。其观点是现象是不服从于僵死的物理学秩序的，这种冲突就是自然界与社会之间的冲突。知识并不是由客官规律生产出来的而是由社会建构出来的。例如原子，在古希腊时期，人们并没有直接观测到原子，但是人们还是“规定了”（想象构造物）原子的存在。</strong><ul><li>举例：例如出现的科学伦理委员会、《银河系漫游指南》</li></ul></li></ul><h4 id="1-1-2-1-科学知识社会学"><a href="#1-1-2-1-科学知识社会学" class="headerlink" title="1-1-2-1 科学知识社会学"></a>1-1-2-1 科学知识社会学</h4><ul><li>场域：秩序</li><li>本体：秩序</li><li>现象：冲突</li><li>目的：秩序</li><li>代表学派：19c 苏格兰爱丁堡默顿学派，其本意为一门关于科学知识的社会学。科学知识本身只是人类社会活动的一种，其与写书没区别。只有社会学家才能把握宇宙真理。例如：英特尔摩尔定律。</li></ul><h4 id="1-1-2-2-科学犯式革命论"><a href="#1-1-2-2-科学犯式革命论" class="headerlink" title="1-1-2-2 科学犯式革命论"></a>1-1-2-2 科学犯式革命论</h4><ul><li>场域：秩序</li><li>本体：秩序</li><li>现象：冲突</li><li>目的：冲突</li><li>在建构主义的前提下，世界的目的是超越性的，由美国科学哲学家库恩提出。不存在唯一真理，世界上的科学知识是在冲突的过程中不断的自我更新，科学的科学性不取决于其是否是正确的，取决于革命性的错误。科学发展存在两个阶段，第一阶段是做题目，做错的越来越多；随着这样的情况的发生，第二阶段就出现了，这样就导致必须整合这些错误，例如：霍金的《时间简史》。</li></ul><h4 id="1-1-2-3-文化本体论"><a href="#1-1-2-3-文化本体论" class="headerlink" title="1-1-2-3 文化本体论"></a>1-1-2-3 文化本体论</h4><ul><li>场域：秩序</li><li>本体：秩序</li><li>现象：冲突</li><li>目的：中心</li><li>世界运行的中心就是个体人类，因为在现象层面，存在着科学知识与人文知识的冲突，但是这种冲突不重要，重要的是由这种冲突所生成的特定的文化模式，同时，这种模式是衡量一个民族、国家是否先进的标志。比如现代政治哲学——由亚历山大·温特提出。这是一种利己的、生长在科学独断论下的一种人文方式，而这种人文方式是对科学独断论的反动。另一点来说，这种东西——文化——既不科学又不人文，也需要知道这种东西是一个共同体的标志，标志着一个国家进行统治以及民族的自我再生产的模式。比如，哈佛女孩（为了所谓的人类的利益）——精致的（把场域和本体通通秩序化）利己（对于科学人文的投机）主义者。</li></ul><h4 id="1-1-2-4-解构建构论"><a href="#1-1-2-4-解构建构论" class="headerlink" title="1-1-2-4 解构建构论"></a>1-1-2-4 解构建构论</h4><ul><li><p>场域：秩序</p></li><li><p>本体：秩序</p></li><li><p>现象：冲突</p></li><li><p>目的：虚无</p></li><li><p>人文和科学之间的冲突是没有意义的、荒谬的，而“我”又不知道世界应该向哪方面走。思想史上对应的人物是美国社会心理学家科尼斯·格根。科学是人类社会的产物，ta 不能揭示真理，这种思维模式用来解释人的心理，这一 π 认为，人的行为都是被偶然的社会活动所决定的，所以不存在稳固的科学和人文。大众文化中的“脑控”受害者，这是由落后的国家走向工业国的过程中产生的必然剩余。</p></li></ul><h3 id="1-1-3-认知主义（Cognitvism）"><a href="#1-1-3-认知主义（Cognitvism）" class="headerlink" title="1-1-3 认知主义（Cognitvism）"></a>1-1-3 认知主义（Cognitvism）</h3><ul><li>场域：秩序</li><li>本体：秩序</li><li>现象：中心</li><li>目的：</li><li>认知科学认为人的体验是一个中心化的产物，这些体验通通是由人的意识所产生的。从各个角度去研究意识解构，就可以构建意识。例如：冯·诺依曼、“聪明”药（人的意识可以通过科学的手段去调整的）。</li></ul><h4 id="1-1-3-1-功能主义（Functionalism）"><a href="#1-1-3-1-功能主义（Functionalism）" class="headerlink" title="1-1-3-1 功能主义（Functionalism）"></a>1-1-3-1 功能主义（Functionalism）</h4><ul><li>场域：秩序</li><li>本体：秩序</li><li>现象：本体</li><li>目的：秩序</li><li>应该叫函数主义，其认为人的体验&#x2F;意识解构均可以用数学化的方式去描述。换句话说，这个世界不存在某个东西能超越数学秩序的存在，这个世界也不存在超越性的目的和终极意义，唯一的目的就是秩序的再生产。学术上比如著名的“哲学家”——希拉里·普特南，杰瑞·福多——所有的心灵状态都只能用思想的语言来描述，思想的语言就是一系列的数学函数。在文化上的对应是“缸中之脑”。对于数理化的崇拜。</li></ul><h4 id="1-1-3-2-自由进化论"><a href="#1-1-3-2-自由进化论" class="headerlink" title="1-1-3-2 自由进化论"></a>1-1-3-2 自由进化论</h4><ul><li>场域：秩序</li><li>本体：秩序</li><li>现象：中心</li><li>目的：冲突</li><li>“自私的基因”——“基因”&#x2F;“文化基因”&#x2F;“模因”仿佛有一种超越性的力量。代表人物：丹尼尔·丹尼特——《意识的阐释》，人的意识结构中有优势的模因会吞噬其它模因，而后变成主导，这个过程中是自由的。这里的冲突是僵死的规则 vs“自由”。</li></ul><h4 id="1-1-3-3-认知自我主义"><a href="#1-1-3-3-认知自我主义" class="headerlink" title="1-1-3-3 认知自我主义"></a>1-1-3-3 认知自我主义</h4><p>场域：秩序<br>本体：秩序<br>现象：中心<br>目的：中心<br>侧重于自我意识的研究，才能探究世界其它事物。所有的意识建构中最重要的就是自我意识的涌现。例如：安东尼奥·达马西奥。在物质层面生成的是元我（有机体），现象层面生成的我是核心我（觉醒的）。为了维护稳态，必须生成自传自我。<br>人的情绪体验比理性和逻辑更重要。世俗文化上对应的是：索罗斯——一个个性张扬，喜欢冒险投机，深陷资本主义的理性的漩涡，要保持自我只能通过此等意识形态。</p><h4 id="1-1-3-4-认知无我论"><a href="#1-1-3-4-认知无我论" class="headerlink" title="1-1-3-4 认知无我论"></a>1-1-3-4 认知无我论</h4><p>场域：秩序<br>本体：秩序<br>现象：中心<br>目的：虚无<br>没有自我的存在，其认为在研究中，必须透过研究者的自我意识才能研究自我意识，这种东西带来了失败，神经元、大脑不是意识，真正的意识在于研究者的透明的背景。彻底投靠了物理主义，自我存在只是一种前现代的残余。<br>理论上代表人物是：梅青格尔，他认为人在研究意识中研究意识是导向失败的，他认为只存在神经元…<br>在文化上对应的是：乔布斯等 IT 资本家<br>忽悠！有本事放弃你所有的那一套东西！</p><h3 id="1-1-4-行为主义"><a href="#1-1-4-行为主义" class="headerlink" title="1-1-4 行为主义"></a>1-1-4 行为主义</h3><ul><li>场域：秩序</li><li>本体：秩序</li><li>现象：虚无</li><li>目的：</li><li>世界是有序的，由秩序所生成的客官的现实，人的体验是不存在的，只有客观行为，人的心灵是混乱黑箱。这出自于 20C 美国心理学家对于心理学的看法，ta 们认为精神分析是什么玩意儿，完全是胡扯。</li><li>心理学只看病人的行为，只管输入和输出，所以直接上刑以驯服&#x2F;“矫正”。例如：雷电法王——杨永信。</li><li>这是科学实在论对于人的反噬。</li></ul><h4 id="1-1-4-1-操作行为主义-极端行为主义"><a href="#1-1-4-1-操作行为主义-极端行为主义" class="headerlink" title="1-1-4-1 操作行为主义&#x2F;极端行为主义"></a>1-1-4-1 操作行为主义&#x2F;极端行为主义</h4><ul><li>场域：秩序</li><li>本体：秩序</li><li>现象：虚无</li><li>目的：秩序</li><li>一个“有序”的世界，世界的真实的东西是可操作的“对象”，人的意识是黑箱，宇宙的目的秩序（变量关系）的循环（再生产），把行为主义里的科学变为数学，学术代表：斯金纳——人的行为分两种，一种是应答性（条件反射）；另一种是操作性的行为（通过实验的方法可以控制的）。例如斯金纳箱，箱子里有小老鼠，老鼠无主动性的行为，但在这里却是有“自由”，得出结论，人不是一个真正意义上的自由的人。另一个是赫尔。</li><li>文化中对应的是：自以为是自由的，但实际上是不自由的——快手、抖音 APP</li></ul><h4 id="1-1-4-2-目的行为主义"><a href="#1-1-4-2-目的行为主义" class="headerlink" title="- 1-1-4-2 目的行为主义"></a>- 1-1-4-2 目的行为主义</h4><ul><li>场域：秩序</li><li>本体：秩序</li><li>现象：虚无</li><li>目的：冲突</li><li>其认为整个宇宙分为两种，一种是分子式的行为；另一种是摩尔式的行为。分子式的行为是彼此孤立的行为——可以用数学物理解释的行为，但是成本太高；研究“整体”行为。这就使此带有一些文化性了。</li><li>代表人物：爱德华·托尔曼，把格式塔心理学带到了这里。</li><li>文化上代表：各种恋爱平台——观察用户行为，帮“你”聊天。看上去人有了整体性的行为，但实际上还是单子式的行为。</li></ul><h4 id="1-1-4-3-应用行为分析"><a href="#1-1-4-3-应用行为分析" class="headerlink" title="1-1-4-3 应用行为分析"></a>1-1-4-3 应用行为分析</h4><ul><li>场域：秩序</li><li>本体：秩序</li><li>现象：虚无</li><li>目的：中心</li><li>整个世界的核心目的——对社会有利，其要的是行为改善（一种社会统治模式）。适用范围较小，只适用于监狱和工厂以及自闭症患者和动物驯养，瘾君子和黑户，学生。其特点是“不能说话、不敢反抗”。所谓“改善”，留下“好的”。</li><li>学术上的代表：《组织行为管理杂志》。</li><li>文化现象：背背佳、小罐茶——改善你的行为</li></ul><h4 id="1-1-4-4-社会行为"><a href="#1-1-4-4-社会行为" class="headerlink" title="1-1-4-4 社会行为"></a>1-1-4-4 社会行为</h4><ul><li>场域：秩序</li><li>本体：秩序</li><li>现象：虚无</li><li>目的：虚无</li><li>心理是不存在的，人的心理行为均是社会行为——符号性的互动——声音、图画……基本物质，毫无意义可言！</li><li>代表人物：米德</li><li>文化对应物：社交软件——微博、微信，里面的照片建构了自我认同，社会性行为的本质是符号性的行为，大家的理解以符号性的互动作为基准点。（“查户口”的方式被广泛的运用的，然而“我”可以设置 3 天可见……）</li><li>科学实在论必然失败，其是对于科学的误解！</li></ul><h2 id="1-2-宗教实在论"><a href="#1-2-宗教实在论" class="headerlink" title="1-2 宗教实在论"></a>1-2 宗教实在论</h2><ul><li>场域：秩序（Cosmos——至高的秩序所主宰的宇宙，神的道）</li><li>本体：冲突（宇宙和主宰之间的对立，Being 和 beings&#x2F;神和凡人的对立，第一实体&#x2F;派生性的实体，太一 The One&#x2F;杂多 the many）</li><li>秩序一元论，科学主义没有这种分裂（秩序和物质是同一种东西&#x2F;物理法则和物理实体是一种东西），但是宗教这里有，存在于前现代，思想来源——被误解的柏拉图——新柏拉图主义&#x2F;庸俗柏拉图主义，理念世界（神，其实是精确到蓝图）vs 现象世界（凡人，根据蓝图造的瑕疵的东西）。理念世界直接生成现象世界。</li><li>文化上：教师的教育行为，老师是无法被质疑的，教师拥有绝对权威，这里面教师和学生是主奴式的辩证法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>ISMISM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哲学</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ISMISM总纲</title>
    <link href="/2025/05/26/%E6%80%BB%E7%BA%B2/"/>
    <url>/2025/05/26/%E6%80%BB%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="哲学意识形态大全"><a href="#哲学意识形态大全" class="headerlink" title="哲学意识形态大全"></a>哲学意识形态大全</h1><p>[主义主义】哲学意识形态大全-总纲】 <a href="https://www.bilibili.com/video/BV1JT4y1K7dp/?share_source=copy_web&vd_source=97f40a460ffc72e925773fa7edbc0a45%5D">https://www.bilibili.com/video/BV1JT4y1K7dp/?share_source=copy_web&amp;vd_source=97f40a460ffc72e925773fa7edbc0a45]</a></p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><ol><li><p>场域 - 存在论框架 &#x3D;&gt;宇宙论、场论</p><ul><li>叙事的背景，意义所在的地方。本体论秩序，本体论论域。</li></ul></li><li><p>本体 - 存在性内容 &#x3D;&gt;本体论、存在论</p><ul><li>场域内的真实存在的东西。研究让现象生成出来的基础性的本体，无法用感觉只能用理智，语词去把握的东西；研究本体之间的关系。只能用理智直观把握的维度</li></ul></li><li><p>现象 - 主体性感知 &#x3D;&gt;本体论、心理学</p><ul><li><p>存在如何向主体显现，什么使得存在向主体显现。</p></li><li><p>人不可能从本体论上彻底理解这个世界(在自然科学中本体论和认识论短路，它就告诉你，世界就是这么运行的，所以你就应该那样去认识。所以认识论维度在自然科学里是多余的 )，而必须从有限的维度出发(承认自己无法接触到现象背后的真实维度会产生幻觉要保留那个维度于未知。主体会有磨难，幸福，努力)去生存</p></li><li><p>人与人之间的伦理关系，必须停留在认识论层面，比如母子之间的亲情，就不能从本体论上还原成族群和个体的利益关系，否则就不存在感情，只有利益了；比如个人对理想的奉献，我们永远不“必”确定这到底是出于毫无私心的崇高，还是出于背后虚伪的自私自利(他牺牲了，他奉献了，这已经……)</p></li><li><p>一旦知道了真相，你就无法行动，无法超出你的认知范围，投入未知当中向他者敞开，你就只能停留在理论的层面，算计得失利弊，你不会尊重、敬畏、关怀和同情，而只是把这一切看作你的本体论和理智直观的对象，玩弄于股掌之中。</p></li><li><p>现代哲学流行的认识论是康德式的认识论</p></li></ul></li><li><p>目的 - 目的论方向 &#x3D;&gt;目的论、伦理学</p><ul><li>目的论调和必然性和偶然性，这里的必然性指的是那种现成的必然性(每时每刻绝对为规则所制定，最终目的也设立好，也就是机械必然)，这里的偶然性指的是那种绝对的偶然(杂乱无序，没有方向)</li><li>亚里士多德有一个潜能现实的理论，潜能是一个事物作为一个尚未实现的自身的一个状态，现实也就是实现了它自身的状态。事物的运动被解释为潜能向现实(这个现实是一个未来的现实，必然的现实，不仅仅指当下，而是成为某个当下)的转化。这样一切事物的运动就不再是一个外在支配下的创造过程，而是一个自我生长的过程。在它这个过程中，它可以自由地，有意义地实现它自己。这样偶然和必然的维度就被调和了。</li><li>目的论试图把握的是处于未来的、尚不清晰的终极原因(历史必然性，最终的发展方向引导了之前的历史进展。总要有一定的意义和价值，这个意义和价值现在看不清楚，但是在遥远的未来，一定会有个清楚的交代。)目的论是超出本体论和认识论的把握的，它代表的是事物的生成和发展的自由力量。目的论守护的是自由和秩序所共享的超越性的维度</li></ul></li></ol><ul><li>填空 <strong>【四种运动】</strong>：</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">场域  本体  现象  目的<br><span class="hljs-symbol">__</span>  - <span class="hljs-symbol">__</span> - <span class="hljs-symbol">__</span> - <span class="hljs-symbol">__</span><br></code></pre></td></tr></table></figure><ul><li>可填 1,2,3,4 四个数字，分别对应：<ol><li>【秩序】同一性、一致性、整全性、循环运动，一种无限无脑的循环运动</li><li>【混沌】对抗性、外在不一致性、分裂的运动，一种二元对立的分裂的运动</li><li>【中心】中心性、中介性、妥协性。“中介化下坠的运动”，二元对立的矛盾被调解</li><li>【虚无】 内在不一致，不可能性，“无”，运动模式未知、</li></ol></li></ul><h2 id="具体介绍"><a href="#具体介绍" class="headerlink" title="具体介绍"></a>具体介绍</h2><h3 id="1-：实在论"><a href="#1-：实在论" class="headerlink" title="1-：实在论"></a>1-：实在论</h3><ul><li>存在论框架是完善的，闭合的，然后无脑循环的，一开头都认为自己的生活秩序（场）是完美无缺可以永远持续下去的，所以可以前反思地安住于其中。</li></ul><h3 id="2-：前观念论的形而上学"><a href="#2-：前观念论的形而上学" class="headerlink" title="2-：前观念论的形而上学"></a>2-：前观念论的形而上学</h3><ul><li>存在论框架是分裂的，划分成道（主动的）和规则（被动的），后者被前者规定。</li><li>把握到了无和有的分裂，存在论系统里有部分东西可以自身去实体化，有部分东西要被实体化。这种分裂是纯政治性的分裂，是关于 power 的。</li><li>其实也就是 rulers 本身的分裂，通过斗争，有部分是失势者，有部分是得势者。%%个人理解:立法者的利益斗争影响法的形态%%</li><li>思维水平在康德之前的哲学，不把主体性当成主体性划到哲学的问题域里面去思考问题的哲学。<br>%%笛卡尔：我思故我在%%</li></ul><h3 id="3-：观念论哲学，真正的哲学"><a href="#3-：观念论哲学，真正的哲学" class="headerlink" title="3-：观念论哲学，真正的哲学"></a>3-：观念论哲学，真正的哲学</h3><ul><li>被主宰者说，我是他们斗争的协调者，我是重要的。</li><li>主体性的地位是很重要的，脱离了它很多东西是无法无条件地成立的。世界的涌现必须以心灵和精神作为中介。如果不是这样，整个宇宙的运动就是没有意义的，失去方向的。</li></ul><h3 id="4-：解放者的哲学，辩证唯物主义"><a href="#4-：解放者的哲学，辩证唯物主义" class="headerlink" title="4-：解放者的哲学，辩证唯物主义"></a>4-：解放者的哲学，辩证唯物主义</h3><ul><li>本体论的框架是开放的，或者不存在的</li><li>物理领域，意义领域等，甚至他们之间的界限都是开放的，是由主体的努力所设立出来</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>1234 对应辩证法的四个步骤:正题，反题，虚假的合题（不可避免的），和真正的合题</li><li>这整个体系按其本身来说是一种庸俗结构主义的非常粗浅的矩阵，但它是有用的，可以判断哲学的立场。如果你真的要去掌握某种哲学的话就大部头一本一本读</li></ul>]]></content>
    
    
    <categories>
      
      <category>ISMISM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哲学</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《悲剧的诞生》读书笔记</title>
    <link href="/2025/05/22/%E3%80%8A%E6%82%B2%E5%89%A7%E7%9A%84%E8%AF%9E%E7%94%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/05/22/%E3%80%8A%E6%82%B2%E5%89%A7%E7%9A%84%E8%AF%9E%E7%94%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-造型艺术（阿波罗）V-S-音乐艺术（酒神）"><a href="#1-造型艺术（阿波罗）V-S-音乐艺术（酒神）" class="headerlink" title="1. 造型艺术（阿波罗）V.S 音乐艺术（酒神）"></a>1. 造型艺术（阿波罗）V.S 音乐艺术（酒神）</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><ul><li>阿波罗艺术，酒神艺术分别对应两种本能</li><li><strong>通过希腊意志的一种形而上学行为，两种艺术融合，诞生了阿波罗式又狄奥尼索斯的阿提卡悲剧艺术作品</strong></li><li><em>注意尼采在文中反复引用叔本华言论，以及对黑格尔美学的批判</em></li></ul><h3 id="1-1-1-梦-阿波罗式"><a href="#1-1-1-梦-阿波罗式" class="headerlink" title="1.1.1 梦-&gt;阿波罗式"></a>1.1.1 梦-&gt;阿波罗式</h3><ul><li>“梦境中美好的假象，是一切造型艺术的前提”</li><li>阿波罗是造型之神，阿波罗式艺术是预言能力的象征类似物，是生活变得可能，有价值。</li><li><strong>然而，梦境与现实之间有一个柔弱的界限；梦是不可逾越的，否则假象就会变为粗鄙的现实</strong></li><li>”个体化原理的壮丽神像；造假像的全部”</li><li>由于叔本华所说的“根据律”，人对现象的认识形式产生怀疑，从而产生一种恐惧。</li><li><strong>喜悦的陶醉</strong>，即<strong>个体化原理破碎时</strong>，从人内心深处本性升起的迷人的<strong>陶醉</strong>；-&gt;醉</li><li><em>总结：梦<del>阿波罗</del>个体化<del>假象</del>与现实的关联<del>恐惧</del>泰坦</em></li></ul><h3 id="1-1-2-醉-狄奥尼索斯"><a href="#1-1-2-醉-狄奥尼索斯" class="headerlink" title="1.1.2 醉-&gt;狄奥尼索斯"></a>1.1.2 醉-&gt;狄奥尼索斯</h3><ul><li>“情绪高涨，主体便隐于一种完全的自身遗忘状态”</li><li>现象：”奴隶也成了自由人，人之间的敌意消失了；醉意之中，载歌载舞之际，人群表现为一个更高的共同体人忘记了行走、说话，甚至认为自己是神；正如人在梦中看见诸神，人在陶醉中也飘然不定，发生变化；<strong>人从艺术家转变为了艺术品</strong>“</li><li>狄奥尼索斯的魔力：人与人、自然和解</li><li>”把贝多芬的《欢乐颂》转化，让我们想象力跟进，想象“</li><li>“万民落入凡尘，化为乌有，从而让我们接近了狄奥尼索斯”</li><li><ul><li><em>总结：醉<del>狄奥尼索斯</del>集体化<del>自然</del>快乐~奥林匹斯</em></li></ul></li></ul><h1 id="2-希腊人与两种艺术"><a href="#2-希腊人与两种艺术" class="headerlink" title="2.希腊人与两种艺术"></a>2.希腊人与两种艺术</h1><h2 id="2-1-奥林匹斯与希腊人的恐惧"><a href="#2-1-奥林匹斯与希腊人的恐惧" class="headerlink" title="2.1 奥林匹斯与希腊人的恐惧"></a>2.1 奥林匹斯与希腊人的恐惧</h2><h3 id="2-1-1”阿波罗式的希腊人和希腊诸神”"><a href="#2-1-1”阿波罗式的希腊人和希腊诸神”" class="headerlink" title="2.1.1”阿波罗式的希腊人和希腊诸神”"></a>2.1.1”阿波罗式的希腊人和希腊诸神”</h3><ul><li>阿波罗式的希腊人对生命的终结产生了恐惧，于是创造了奥林匹斯；而原始的泰坦式的恐怖诸神制度，转变为了奥林匹斯的快乐诸神制度；</li><li>泰坦式奋斗的个体势必要亵渎神明，于是**智慧近乎是一种反自然的事物“</li></ul><h1 id="3-以《俄狄浦斯王》和《普罗米修斯》为例"><a href="#3-以《俄狄浦斯王》和《普罗米修斯》为例" class="headerlink" title="3. 以《俄狄浦斯王》和《普罗米修斯》为例"></a>3. 以《俄狄浦斯王》和《普罗米修斯》为例</h1><h2 id="3-1-俄狄浦斯王-普罗米修斯共有的泰坦式欲望"><a href="#3-1-俄狄浦斯王-普罗米修斯共有的泰坦式欲望" class="headerlink" title="3.1 俄狄浦斯王&amp;普罗米修斯共有的泰坦式欲望"></a>3.1 俄狄浦斯王&amp;普罗米修斯共有的泰坦式欲望</h2><ul><li>他们的个体化、智慧是他们一切苦难的根源。</li></ul><h2 id="3-3-阿提卡新喜剧"><a href="#3-3-阿提卡新喜剧" class="headerlink" title="3.3 阿提卡新喜剧"></a>3.3 阿提卡新喜剧</h2><ul><li>”仍然残存着悲剧的蜕化状态，构成悲剧极其艰难和惨烈的消亡的纪念碑；</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哲学</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>媒介论</title>
    <link href="/2025/04/09/%E5%AA%92%E4%BB%8B%E8%AE%BA/"/>
    <url>/2025/04/09/%E5%AA%92%E4%BB%8B%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="这是一个纯粹基于个人经验的“学术著作”"><a href="#这是一个纯粹基于个人经验的“学术著作”" class="headerlink" title="这是一个纯粹基于个人经验的“学术著作”"></a>这是一个纯粹基于个人经验的“学术著作”</h2><ul><li>文中所有的结论、论据，并没有得到很严谨的证明。仅仅只是我个人对自己十多年的学习实践经验的一个总结。</li><li>正由于是在学习和实践中总结的，本文章的理论带有很明确的指向性——从学习工作的角度考察媒介的特质。</li><li>最后，写本文纯粹是出于练笔和消磨时间，在文字逻辑性难免会有疏漏。还望包涵。</li></ul><h1 id="一、现代社会的媒介"><a href="#一、现代社会的媒介" class="headerlink" title="一、现代社会的媒介"></a>一、现代社会的媒介</h1><ul><li>本文所说的媒介，指的是所谓的信息媒介，由人类&#x2F;机器输出信息，承载到纸、视频等媒介中，再被人类&#x2F;机器输出。而人类再输入时，要通过看、听等方式去感知到信息，将信息存入大脑中处理，又可以写、说等方式输出信息到媒介中。</li></ul><h2 id="电子媒介VS-传统媒介"><a href="#电子媒介VS-传统媒介" class="headerlink" title="电子媒介VS 传统媒介"></a>电子媒介VS 传统媒介</h2><ul><li>如今的社会，人们获取信息的媒介早已不局限于传统的物理媒介，视频，博客，网页，电子书……也是如今重要的知识载体。</li></ul><h2 id="其他的分类方法"><a href="#其他的分类方法" class="headerlink" title="其他的分类方法"></a>其他的分类方法</h2><ul><li>除此之外，我们还可以按从媒介中获取信息的方式来对这些媒介进行分类：纯粹使用视觉的如书报；用听觉的，如博客；多种感官并用的，如视频。</li><li>还有一种特殊的分类方法，可以说是我自己首创的。就是按接收者的主观能动性分类：从书籍，图画这些需要你自行去阅读获取知识的，到视频这种自动播放，哪怕你不需要太多注意力，也能多少获得一点，而且视频往往会有一个人担任“讲师”这一职位讲述文案（当然，也有视频纯放图片的，那种幻灯片其实本质还是书籍那样的媒介形式），接受者的主观能动性较弱。这种分类方法实则不太严谨，举个例子，有些书本也会又很多作者的个人叙述。但是这样的分类方法是总结了各种媒介的使用感受的，对我们的生活实践具有很大的启发意义，我将在后面详细说明。</li></ul><h1 id="二、基于现实生活和主观条件的媒体选择策略"><a href="#二、基于现实生活和主观条件的媒体选择策略" class="headerlink" title="二、基于现实生活和主观条件的媒体选择策略"></a>二、基于现实生活和主观条件的媒体选择策略</h1><h2 id="为什么要做媒体选择策略"><a href="#为什么要做媒体选择策略" class="headerlink" title="为什么要做媒体选择策略"></a>为什么要做媒体选择策略</h2><h3 id="高效利用我们的时间"><a href="#高效利用我们的时间" class="headerlink" title="高效利用我们的时间"></a>高效利用我们的时间</h3><ul><li>设想一下，你要学习一个技能，你可以选择看书，可以选择看视频教程，甚至是听博客。对于没有任何基础的人，视频对于他们门槛更低，毕竟有人带着自己学习，而对于某些有一定基础的人来说，跟着视频恐怕只是在浪费时间，而书本相比之下控制阅读所需摄取内容和摄取速度更快（就像阅读字幕往往比听人说话更快听完。</li><li>再设想一个情景，假如你要学习一个很简单的概念。听视频你大概率会觉得啰嗦，而看书更加一目了然。</li><li>还有一种情景，此时的你感到眼睛酸痛，但又希望自己忙碌起来，比较适合健康和当前情况的媒介就是博客这种以听觉为主的。</li><li>这可能听着很不讲道理。为什么一定书本就比视频简约？为什么书本更需要集中注意力，不适合基础弱的人。<strong>这一切都指向一个媒介，最实践的学习，就是实践本身。</strong> 没有什么媒介能比得上实践本身来得更加详细，更加深刻。但是，实践总是会遇上挫折，而且他人的实践无法输入给他人，必须由他们亲自实践。这样，要想获得前人的实践智慧结晶，我们就借助了其他媒介，去传递给他人。而显然，视频更加直观，符合我们观察的直觉，更有在现实中实践的感觉。而相比下，其他媒介多少离现实世界遥远。至于为什么会觉得视频啰嗦，正是视频将实践的细节更加详细地，尽可能忠实地还原了。对于那些人掌握良好的人，抽象的知识早已被理解透后装进了脑袋，本身自己也进行了不少实践。再去看重复地实践行为不免觉得重复，没必要。</li></ul><h3 id="找到适合自己的学习方式"><a href="#找到适合自己的学习方式" class="headerlink" title="找到适合自己的学习方式"></a>找到适合自己的学习方式</h3><ul><li>如前文所述，不同水平的人有不同适合的学习方式，找到适合自己的媒介能起到事半功倍的作用。</li></ul><h3 id="减轻身体负担"><a href="#减轻身体负担" class="headerlink" title="减轻身体负担"></a>减轻身体负担</h3><ul><li>减少对单一媒介的使用，去增加对别的感官的使用时间，从而减少单一器官的疲劳感，降低整个身体疲劳感。</li></ul><h2 id="单一某种媒介的承载体可以不同"><a href="#单一某种媒介的承载体可以不同" class="headerlink" title="单一某种媒介的承载体可以不同"></a>单一某种媒介的承载体可以不同</h2><h3 id="传统媒介的不同承载形式"><a href="#传统媒介的不同承载形式" class="headerlink" title="传统媒介的不同承载形式"></a>传统媒介的不同承载形式</h3><ul><li>哪怕是纸质媒体，彼此之间也有不同，可以说是承载体的不同。</li><li>比如，同样是书本，你可以是用严谨文笔写下的教程，也可以是自己思考的笔记。组织形式，内容偏向有所不同，可能书本解释更详细，笔记高度概括，有自己的思考。</li><li>除此之外，你是写在是什么纸上？是活页纸，还是便利贴。不同的承载体形式，可能会影响媒介内容的保存。</li></ul><h3 id="计算机媒介承载形式——格式与平台问题"><a href="#计算机媒介承载形式——格式与平台问题" class="headerlink" title="计算机媒介承载形式——格式与平台问题"></a>计算机媒介承载形式——格式与平台问题</h3><ul><li>信息时代下，文件格式和文件发布平台也是要考虑的问题。可能要学习保存的内容是来自网页，来自公众号…… 除非转化格式（比如都截图保存），这些不同平台的文字很难单纯像物理世界那样简单“粘合”在一起。</li></ul><h3 id="不同的承载体可能存在不同问题"><a href="#不同的承载体可能存在不同问题" class="headerlink" title="不同的承载体可能存在不同问题"></a>不同的承载体可能存在不同问题</h3><h1 id="三、-媒体使用-整合策略"><a href="#三、-媒体使用-整合策略" class="headerlink" title="三、 媒体使用&#x2F;整合策略"></a>三、 媒体使用&#x2F;整合策略</h1><h2 id="有关物理-传统媒介的"><a href="#有关物理-传统媒介的" class="headerlink" title="有关物理&#x2F;传统媒介的"></a>有关物理&#x2F;传统媒介的</h2><h2 id="关于电子媒介的"><a href="#关于电子媒介的" class="headerlink" title="关于电子媒介的"></a>关于电子媒介的</h2><h2 id="将两者结合"><a href="#将两者结合" class="headerlink" title="将两者结合"></a>将两者结合</h2><h2 id="最终回到实践本身"><a href="#最终回到实践本身" class="headerlink" title="最终回到实践本身"></a>最终回到实践本身</h2><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思考</tag>
      
      <tag>杂文</tag>
      
      <tag>随笔</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>忙里偷闲2</title>
    <link href="/2025/04/02/%E5%BF%99%E9%87%8C%E5%81%B7%E9%97%B22/"/>
    <url>/2025/04/02/%E5%BF%99%E9%87%8C%E5%81%B7%E9%97%B22/</url>
    
    <content type="html"><![CDATA[<ul><li>我发现自己每一周总有一个夜晚难以入眠，总有一个白天在奇思妙想，思考自己的未来和过去，思考那些离我很远的人和事。为自己的现实窘境犯愁，但确不想去做那些于当前处境紧密联系的事情。</li><li>经历这么多次这种感受，我现在已经能泰然面对了，甚至有了一套自己的攻略。首先，思考一下导火索——嗯，是即将到来的大英赛，但是自己什么都没准备。还有，在上数学时感觉自己被刁难了，很不舒服，对自己的能力的自信产生动摇。大概就是这些，说白了，就是刻在骨子里的焦虑、自负和完美主义追求和当前处于教育体系竞争下源源不断的ddl和优绩主义氛围叠加产生的困苦。嗯，还是熟悉的配方。</li><li>该怎么做。根据经验，首先我该平定一下心情，先放纵一下，不错，我今天可太放纵，相较于前几天来说。放纵之后，我肯定会本能地产生空虚感，于是开始在书本也好，互联网也好，去寻找一种解放感。</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思考</tag>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux相关的视频笔记</title>
    <link href="/2025/02/16/Learning%EF%BC%9ALinux+English/"/>
    <url>/2025/02/16/Learning%EF%BC%9ALinux+English/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux-英文"><a href="#Linux-英文" class="headerlink" title="Linux+英文"></a>Linux+英文</h2><ul><li>bv: BV1c1421C7aC</li></ul><h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul><li>mandatory–必要的</li><li>rate –&gt;工资（生）</li><li>Linux 指令</li><li>man ls 查看 man 手册</li><li><code>.</code> 的含义（ from shell) - <code>.</code>、<code>..</code> —&gt;当前目录，上一级目录 - 文件前面带 <code>.</code> 表示是隐藏文件</li><li><code>DEST</code> –&gt;destination of somewhere</li><li><code>SOURCE</code> –&gt;原本的</li></ul><p>Method</p><ul><li>先学会技术语境，再去转换英文理解</li><li>着重理解关键词，名词</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>似曾相识燕归来——24年总结</title>
    <link href="/2025/01/28/%E4%BC%BC%E6%9B%BE%E7%9B%B8%E8%AF%86%E7%87%95%E5%BD%92%E6%9D%A5%E2%80%94%E2%80%9424%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <url>/2025/01/28/%E4%BC%BC%E6%9B%BE%E7%9B%B8%E8%AF%86%E7%87%95%E5%BD%92%E6%9D%A5%E2%80%94%E2%80%9424%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<ul><li>按理来讲这样的回顾性随笔应该在跨年时候写的，奈何那时正在忙期末考。忙完期末考又盼着回家，回到家又在无所事事，拖着拖着就到了除夕，所以严格意义上讲不妨说是龙年总结</li><li>不过话又说还来，除夕理应是我最忙的时候——忙着进行必要的社交活动，忙着玩，但是今天却又有时间在这卖弄文字，诉说苦水。</li><li>躁狂，是内心的躁狂。24年来，来自身边的、社会的、世界的讯息，都让我隐隐约约有着不详的预感，总是辗转反侧，寤寐思服。既然此，与其在这样的总结随笔中把自己的过往如流水账般无情地述说出来，不如聚焦于这一年来一直支配在我心里的哪些苦痛的来源，虽然着也只是内心的猜测</li><li>首先，我真的不想和亲戚们打交道，别说哪些家里的长辈了，就是平日学校里的同学，我都要处心积虑地想着怎么样应对。但我怎么可能不来，这个任务是作为这个家里的人必须得完成的，这个道理早在我小学时，因为不想拜访亲戚时，“离家出走”最后还是被我妈教育了一顿时就意识到了。这就像为了保留电话号交的5元&#x2F;月的电话费一样。同样地，压岁钱我也没什么指望的，反正我很早就用来交学费了，再说了，我也马上到了要我给别人压岁钱的年纪了</li><li>我自认为自己不擅长打交道，虽然跟比较熟的人我可以大胆交流，但我从来没法真正的和别人敞开心扉。总是对别人持有揣测、警惕之心，哪怕是自己的亲人。为什么，我想，或许是自己内心的那点可怜的傲气，或许是在我自己都不知道的时候什么事物造成了某种创伤。并且这种状态本身，这种原因本身也让我感到不安。一是我明明找到了一个突破点我却无法克服这样的障碍，二是古往今来不管是什么制度的社会，能说会道者总能在其中如鱼得水，沉默寡言者，要不死后才能被世人挖掘其背后的智慧，要不干脆就是个傻子。我承认自己我有一些不切实际的庸俗幻想，想成为一个巧言令色者获取不义之财。但是现实的窘迫处境注定让我对钱财之物以及阶级尤其敏感，我很厌恶这样的想法，但这玩意却像个胎记一样永远不能去除似的。</li><li>说到钱，我对钱财本身也有深深地不安感，不仅仅是因为立场的原因，还有对世界未来深深的不安感。不过，我本人绝对不是这方面的专家，这些见解我相信是十分浅薄的。</li><li>国际局势上，欧洲方面经济早在二战之后就陷入了疲软，移民问题愈发显著；美国方面，人民处境更加地水深火热，又有了特朗普这样的定时炸弹上台；至于国内，经济涨势也开始变缓，科技方面是取得了显著的进步，但是和这形成鲜明对比的是年轻人对于就业方面的不满，无法消化的人才，制造业某些领域仍然难以实现向高端的迈进，还有某些行业无止境的“内卷”（别我提什么商家内卷消费者受益，商家不是傻子，所有降低的成本对是向对消费者售卖产品未来开刀的）…… 更重要的，是世界普遍地某些右翼保守主义抬头。啊，也有可能是我年轻了，或许这个世界上发声最响的此前一直是这帮人，不过是我现在长大了突然意识到了。但是第三世界，是真的切切实实地发生战争了，而这样的战争不是此前的伊拉克战争这样的还要更加庞大。今年我比任何时候都要更多次听到“战争”这个字眼。也有可能是室友爱念叨这事吧。我相信以国家目前的军事水平，若中国本土真烧起了战火，也不至于让人民损伤惨重。再说了，以我本人庸俗的认知水平和浅薄的历史储备，目前世界的这般状态要一场战争去将这些脓包挤出来，重建战后世界秩序。而且，我认为，国家或许是这场战争的关键突破口。但是，我对能力抱有乐观态度，但是对后核时代下战争的结局表示深深的忧虑——或许昭示希望的曙光，抑或是毁灭世界的利器，搞不成真的就像《辐射》里的故事那样了。但是能遇见的是，如果真发生了战争，那么物价必然飞涨，通货膨胀不可避免，底层人民一定会是战争中过得最惨烈的。并且战争难以预测，谁也不知道，什么时候，会有第二个萨拉热窝事件发生。</li><li>说些离我生活近一些的吧，谈谈学业带给我的苦痛。</li><li>我的2024，被高考分成了截然不同的两端。很难想象，一年前的我还是个（勉强）手撕导数圆曲答题，擅长生物的高三生。我一直不能理解为何有人会去怀念高三，直至现在，当我想起高三，，想起高中，涌上心头的第一感想是怀念没错，但随之而来确实一种悲痛和惆怅。我可惜我高中时的畏缩，可怜我高二时被抑郁情绪折磨，耗费父母的时间精力，过了一段行尸走肉般的日子，可恨我的愚笨，我到现在都不能直面自己的高考成绩，不愿回去宣讲，骨子里还是对自己有着那股自卑劲。不愿意直面自己的真实，哪怕我到了这个我并不稀罕的学校还是发现“人外有人，天外有天”。然后我的思绪有很快的回到现状的惨淡，一事无成，无所事事，白白蹉跎了一个学期。我努力说服自己爱着这个学校，但事与愿违。别人会鄙视，更可怕的是我自己有时又跟别人统一战线一起鄙视了。</li><li>我这人真的很奇怪，我的两面就像硬币的两面一样，有泾渭分明的分界线。一面是在乎世俗目光和学历的我，另一面是鄙视鄙视链，希望沉下心来做真正学问的我。</li><li>那个想做学问的我，其实有时候也会被世俗的我挟持，希望发达。但是，我确定自己是想做一些真正的学问的，并不是指我一定要考研保研，我不想做一个为了那点子薪水的涨幅就去混个学历。而是一辈子做一个较真的人，为知识着迷，为人类的智慧光辉和成就动情。幸运的是，我在烦躁的2024年还是偶然达到了这个目标，尤其是大学，我尝试了很多，我开始摆脱此前经验主义形成的对计算机的认识，真正系统地探索这个广阔的世界，我又一次开始尝试入门哲学，但这次我是怀着求知和询问的心态去学习的，我去做一个真正对现实产生影响的项目，去真正了解一个行业以及更加冷漠的现实。</li><li>我做了很多对生存和利益无意义的事，但我知道我注定要这样，注定会成为那个默寡言者，那个在亲戚和朋友眼中有些单纯古怪的人。这不是我对命运这一虚无缥缈的事物的认可，而是我对自己的背景的一种释怀和对此倒向的必然性的理解。命运之一词本身就包含了人生可变这一与之对立命题。我小时候就在思考，别人是怎么看待我的，成为别人是怎么一个感受，长大后我又会在思考如果我没出生在这个家庭会怎样，没做那样的事会怎样…… 但是我又马上醒悟过来了，成为别人的我就根本不是我，没经历过这些现实经历过的就不是我，再说我怎么又可以对未经验的事物进行感知和判断的的。所以说，不管怎样落得一地鸡毛，只有现在这一瞬间是无比真实且有效的， 我能做的，就是打扫这异地鸡毛，继续做我该做的事，想做的事。</li><li>这是现在愚蠢的我给出的答案。</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读后感</tag>
      
      <tag>思考</tag>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8-11.25总结</title>
    <link href="/2024/11/08/%E4%BB%8E%E6%9A%91%E5%81%87%E5%88%B0%E5%8D%81%E4%B8%80%E6%9C%88%E4%BB%BD%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%98%9F%E6%9C%9F%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%8811.8%EF%BC%89%201/"/>
    <url>/2024/11/08/%E4%BB%8E%E6%9A%91%E5%81%87%E5%88%B0%E5%8D%81%E4%B8%80%E6%9C%88%E4%BB%BD%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%98%9F%E6%9C%9F%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%8811.8%EF%BC%89%201/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>写这篇文的目的，主要是想记录一下自己的学习和生活轨迹，往后再看时能对自己点的技能树有明确的认识</li></ul><h1 id="八月-九月——以-CS50-为主轴"><a href="#八月-九月——以-CS50-为主轴" class="headerlink" title="八月-九月——以 CS50 为主轴"></a>八月-九月——以 CS50 为主轴</h1><ul><li>终于有时间去听大名鼎鼎的 CS50,我用了八月一整个月上到了 week8，经历了九月二十多天的军训后，终于在十月份初强行完成了整个课程（SQL,FLASK 和 Final project 都没完成)，计时两个月左右，期间还摸了不少鱼，就连不少作业都是抄网上的。这门课在哈佛实际的授课时间大约是三个月左右。不过作为非哈佛学生，在没有 TA 和别的同学帮助的情况下，我认为我尽快过完整个课程的总方针是正确的。 上这门课程我的目的就是纵览计算机领域。通过这门课，我收获了:</li></ul><ol><li>基础的 c 语言语法和指针的运用，以及对数据结构的初步了解</li><li>python 的基本语法</li><li>前端的初步了解和前端框架的简单运用</li><li>数据库的基本使用</li><li>多种编程语言结合在一起完成一个项目的经验</li><li>算法的初步了解，如冒泡排序、二叉树、哈希表，让我认识到算法并不是什么很高大上的东西，它是我们在日常编程中就必须考虑的一环</li><li>计算机网络的小知识</li><li>编程思想的认识：如何写出更加简洁、全面的代码？——要考虑到多种情况，有“防御性编程”的思想；要对代码精益求精：比如尽量减少重复代码；还有对安全性的考量，如要考虑到 sql 注入的安全隐患而采取占位符填充的策略</li></ol><h1 id="十月——疲于现世的繁杂事务，缓慢进行计划"><a href="#十月——疲于现世的繁杂事务，缓慢进行计划" class="headerlink" title="十月——疲于现世的繁杂事务，缓慢进行计划"></a>十月——疲于现世的繁杂事务，缓慢进行计划</h1><ul><li>十月才正式拉开了上课的帷幕，虽然说呢我们的课已经算少了，但这并不影响自己仍觉得碌碌无为，对自己的时间手足无措。一堆无意义的课程和作业，诶！！！</li><li>因此十月并没有学习太多东西，更多的是在适应学校生活的习惯。当然，除了基本的微积分外，我在 web 开发和计算思维中也收获了一些东西。只是，我还是觉得收获的知识密度远没有在 cs50 中收获的那么多，或许像 David Malan 这样富有激情、能吸引同学沉浸课堂的老师真的是少数吧。</li><li>在 web 部门中，我学到了：</li></ul><ol><li>对 css 的进一步窥看</li><li>对 JavaScript 的进一步了解，如何用 JavaScript 写一个计时器</li><li>git 的基本使用（老实说很早就了解并下载了 git，但一直没尝试使用</li><li>了解到像 bootstrap 这样的前端框架的强大——虽然是 ai 告诉我怎么用的</li></ol><ul><li>对于计算思维课，虽然说老师讲的实在是有点无聊，但我很欣赏这个课程的设计，让同学了解到 python 的强大和各种使用方法和途径，让我也额外收获到了一些知识:</li></ul><ol><li>使用 python 画图</li><li>对于 python 处理文件的进一步深入</li><li>面向对象编程的哲学和方法以及封装思想</li><li>中文的编码问题（之前 cs50 作业基本都是英文写的，所以基本没遇到编码问题）</li></ol><ul><li>除此之外，我在尽量找时间阅读《算法竞赛入门经典》。目前计划是先看完 c 语言的前四章，一口气看完后再细品其中的编程和作业，不过目前还在第三章，c 语言的核心语法我都再 cs50 中有了很多的了解，而这本书有帮我补充一些细节：<ol><li>c 语言的数值溢出问题</li><li>算法竞赛的规范（话说这算 c 语言吗）</li><li>逆向思维的运用</li><li>不同数据类型的细微差别</li></ol></li></ul><h1 id="十一月-1-10"><a href="#十一月-1-10" class="headerlink" title="十一月 1-10"></a>十一月 1-10</h1><ul><li>主要干的事就是尝试建博客，最大收获——可能是加深了对 node 和 git 的了解？</li><li>用的别人的框架主题，还做了很多无用功，真是越想越觉得自己愚蠢。</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="课外阅读"><a href="#课外阅读" class="headerlink" title="课外阅读"></a>课外阅读</h2><h3 id="《在轮下》——浅尝黑塞的文学世界"><a href="#《在轮下》——浅尝黑塞的文学世界" class="headerlink" title="《在轮下》——浅尝黑塞的文学世界"></a>《在轮下》——浅尝黑塞的文学世界</h3><ul><li>尝试了大名鼎鼎的黑塞的作品，可惜遇到了个很烂的译本。幸好大体思想还是能传达到的。其中传达的对应试教育体系的怀疑，书中的各类人物对于优绩的看法，在如今仍有参考意义，也对正处于这其中的我带来一些思考</li></ul><h3 id="中科大《数学分析教程》"><a href="#中科大《数学分析教程》" class="headerlink" title="中科大《数学分析教程》"></a>中科大《数学分析教程》</h3><ul><li>由于对我们学校的指定教材感到了些许失望，我便将目光投向了其他的数分教材。通过中科大数学指南的推荐，我入手了他们的数分教材。诚然，这是一本好教材，它逻辑清晰严谨，介绍全面，思想深刻。但实在是对我这样数学一般的学生不太友好，其实细细思考还是能理解的，还是读慢一点好了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读后感</tag>
      
      <tag>思考</tag>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于这个博客</title>
    <link href="/2024/11/07/%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/11/07/%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<ul><li>2024 年的十一月十七日晚上的 8:09 时，输入最后一条指令”hexo s”,修改的网页终于出现在我的眼前，我知道我的工作进行的差不多了。</li><li>也许有人会觉得:”不就是一个个人博客吗？真的有这么难配置吗？”</li><li>是啊，好像是不难。可是我却常常不愿意思考:仅仅只是照着网上的教程照葫芦画瓢，遇到问题就问 AI。我肯定是有能力去搞清背后的原理的，但是背后总有一股力量在催促我别管那么多快点建成，哪怕我花了一个晚上+一天的时间去完成这个没有任何知识收获的小项目。</li><li>这股力量: 来自内心渴望一个心灵的住所的欲望。从小到大，我从来没有一个真正属于自己的房间。家里还没买房时，住的是出租屋，除了卧室，就是厨房和厕所了，父母和我只能挤在一张床上; 买房后，我短暂地拥有了自己的房间……..吗？——房间的大门永远被家人敞开，客厅与我的房间相连，我根本没有自己的隐私。夏天的时候，客厅里没空调，家里人就到我的房间里做的，这还是属于我的房间吗？后来，弟弟长大了，他也不能总是和父母睡啊，又没有别的房间，于是就搬到下床来了，我睡上床，当然，其他人还是爱咋咋样。再后来，我上高中、大学了，去了集体宿舍，虽然还是没有属于自己的房间，但终于有了不被长辈发现的可以自己装饰的小天地了。</li><li>我总是向往着别人的房间。看电影时，我总会在意角色们的房间。我印象最深刻的房间是电影《头号玩家》中哈利迪（应该是叫这名字）的房间：小阁楼里摆放着各种设备，墙壁上贴满了海报，热爱和激情包裹着这个温馨的小空间。这是我一直梦魂萦绕的理想房间呀。</li><li>然而，距离我工作、搬出去一个人住还有一段时间呢。或许我还要出去读研，可能还要再住一段时间的集体宿舍。既然此，我不如先建一个赛博房间吧，于是我的博客落地了，我从高二开始就有的一个小梦想实现了，并给博客一个小代号“部屋”（参考了《未麻的部屋》）。虽然现在还是用着别人模板的默认背景和样式（实在没法找出一大块空闲时间装饰），但慢慢地，我会再次基础上增添一些自己的色彩，等着吧，我将我的心托付于此，而房间的布置才刚刚开始。</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思考</tag>
      
      <tag>杂文</tag>
      
      <tag>介绍</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>忙里偷闲其一</title>
    <link href="/2024/10/14/%E5%BF%99%E9%87%8C%E5%81%B7%E9%97%B21%EF%BC%882024.10.14%EF%BC%89/"/>
    <url>/2024/10/14/%E5%BF%99%E9%87%8C%E5%81%B7%E9%97%B21%EF%BC%882024.10.14%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li>我总觉得自己像一个气球。</li><li>我要花一段才能把志气充满。一旦冲完，就会将气以极快的速度放出，马上泄光气。随后又得花一段时间给自己充满气。</li><li>前几天，我已经把气泄完了。哪怕今天是工作日，哪怕还有三天自习的硬指标，还有比赛和作业的 ddl 如同达摩克里斯之剑一般悬在我头上，我必须歇息一下。否则，焦虑会把我淹没，无法工作也无法休息，只能徒劳耗尽自己的精力。</li><li>既然决定休息，那么，要干什么呢？看书？是啊，我一直可惜自己在年少时期没怎么接触书籍，上了高中又苦于学业压力只能将书本束之高阁。现在，不管怎么忙碌，我都有理由和有必要以自己的期望和目标安排自己的生活。扫视一眼书架，那这本了。赫尔曼·黑塞的《在轮下》。最后，我以一种吊儿郎当的态度，用了一个下午的时间，粗略过完了这部短篇小说。现在，我心中有了对这篇小说大致的感想：“的亏我在一个正确的时机看了这本书”</li><li>似乎，这本书的读者都会认为自己像汉斯。正常，毕竟那些文艺青年都有点叛逆的小情绪，不过归根到底又都要接受社会的那套规则和那套应试教育体系。我又何尝不是一种汉斯？从家境上，我算不上汉斯那种小资产阶级。但是，从小地方（大城市郊区也可以是一种小地方）出身，在身边的赞美长大，对感情的模棱两可的态度，对自然自由的向往，最后高开低走的结局——我从汉斯身上看到了自己的影子，尤其是那种对自身道路的不确定。做不到像赫尔曼才华横溢放荡不羁并毅然决然的抛弃前程，也做不到像卢修斯那样安然待在象牙塔中对自己奉行的那套规则坚信不疑。我总是在怀疑，总是在摇摆。坦白说，我还是有一种出人头地跨越阶层的庸俗思想，但同时我自己又对这样的思想是鄙夷的。我尊重所有劳动者，但你让我做一名体力劳动者，我无法做到，尤其是在身边人的凝视下；我喜欢也喜欢幻想：幻想自己住在一个阁楼，墙上贴上自己喜欢的海报，放一个软榻的沙发，旁边堆放自己爱吃的零食。工作桌上整齐罗列着齐全的工具、模型、设备······没有人能随意进出我的房间，除了我，这里是我的天地，安放我不安的心灵的容器。但是就像汉斯面对困难的希伯来语，我也要面对大学繁琐的杂事和困难的课程。幻想，幻想，幻想不能解决任何事，我还是那个汉斯，仍然是那个对赫尔曼崇敬的汉斯，那个普通的汉斯，处在进退两难的境地。的亏在这是看了这本书，它是如此精准的描述了我一直以来的处境。（哪怕我看了一个超级垃圾的译本）</li><li>也的亏是现在看了，否则又要陷入对所谓社会规则的无意义解构和宣泄般地炮轰的无意义批判了（老实说，这样玩很爽，但我明白这也仅仅停留在好玩而已）如今的我认为，真想对这样的体系做出什么改变，你首先就得成为体系中的佼佼者，获得改革的权力，当然，你也万万不可深陷于此，把这象牙塔的一切当作了全部。或许大家应该庆幸自己是汉斯，既没到像卢修斯那样无可救药的愚钝，还没到像赫尔曼那样可以安心的做社会的突刺。处在疑惑的境地，反而也拥有了怀疑的机会。怀疑，怀疑又是整顿自己心思好时候了。像书中结局那样孤独的死去，这是一种浪漫的带有悲观色彩的艺术处理结局。没必要把自己活成一个艺术品，被别人作为素材。不如利用自己的主观能动性和俯瞰的视角，在这窘迫的境地如鱼得水地生活，或许才是正道。忽然想起米开朗基罗说的“我们每个人都是命运的奴隶”。跳出这个对于一个目前无解的辩题的二元辩证，才具有现实意义，才接近“革命”这一性质吧。</li><li>所以说，我真的真的没必要再因为周围的人事焦虑，不是因为一种得过且过的思想，而是是一种对自己能动性和理性的相信。我还有解析自己的能力，还有学习的能力，还有自己的热爱和理想，理应上我最终是可以回归一种自己理想的生活方式，这是理性这一可预测未来的事物告知我的。当然，纵观我这么多年的日记其中蕴含的思想。我觉得自己还是位庸俗之人，思想似乎没有彻底革命，时不时还是会被上述我早已回答的问题头疼，不过，我会主动的写日记，作为一种充气的方法，也能让让自己再次回归最初的想法。</li><li>这就是目前我对迷茫和规则的解法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读后感</tag>
      
      <tag>思考</tag>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
